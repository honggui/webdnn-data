{
  "kernel_source": "\n#include <metal_stdlib>\nusing namespace metal;\n\n#define OPTIMIZE 1\n\n\nkernel void im2col_c11bc86fe77290c624886ebd52e1e88ff9cb3655ad3bfada8b15ad55(const device float *param_buffer[[buffer(0)]],\n                          device float *data_buffer[[buffer(1)]],\n                          const device int * meta_buffer [[buffer(2)]],\n                          ushort index_thread[[thread_position_in_threadgroup]],\n                          ushort index_group[[threadgroup_position_in_grid]])\n{\n#define SH_EQUAL_1 1\n#define SW_EQUAL_1 1\n#define C1_DIVIDABLE_BY_4 0\n\n\n#if OPTIMIZE && C1_DIVIDABLE_BY_4\n    const device float4 *im4 = (const device float4 *)(data_buffer + meta_buffer[0]);\n    device float4 *col4 = (device float4 *)(data_buffer + meta_buffer[1]);\n    const int C1_4 = (meta_buffer[3]) >> 2;\n#else\n    const device float *im = data_buffer + meta_buffer[0];\n    device float *col = data_buffer + meta_buffer[1];\n    const int C1 = meta_buffer[3];\n#endif\n\n    // const int N = meta_buffer[2];\n    const int H1 = meta_buffer[4];\n    const int W1 = meta_buffer[5];\n    const int H2 = meta_buffer[6];\n    const int W2 = meta_buffer[7];\n    const int KH = meta_buffer[8];\n    const int KW = meta_buffer[9];\n    const int PH = meta_buffer[12];\n    const int PW = meta_buffer[13];\n\n#if !OPTIMIZE || !SH_EQUAL_1\n    const int SH = meta_buffer[10];\n#endif\n\n#if !OPTIMIZE || !SW_EQUAL_1\n    const int SW = meta_buffer[11];\n#endif\n\n    const int H1P = H1 + 2 * PH;\n    const int W1P = W1 + 2 * PW;\n\n    const int w1 = (index_group % W1P) - PW;\n    const int h1 = (index_group / W1P % H1P) - PH;\n    const int  n = index_group / W1P / H1P;\n\n#if OPTIMIZE && C1_DIVIDABLE_BY_4\n    for (int c1_4 = index_thread; c1_4 < C1_4; c1_4 += 64) {\n        const float4 v4 = (h1 < 0 || h1 >= H1 || w1 < 0 || w1 >= W1) ? 0 : im4[((n * H1 + h1) * W1 + w1) * C1_4 + c1_4];\n#else\n    for (int c1 = index_thread; c1 < C1; c1 += 64) {\n        const float v = (h1 < 0 || h1 >= H1 || w1 < 0 || w1 >= W1) ? 0 : im[((n * H1 + h1) * W1 + w1) * C1 + c1];\n#endif\n\n#if OPTIMIZE && SH_EQUAL_1\n        for (int kh = 0; kh < KH; kh++) {\n            const int h2 = h1 + PH - kh;\n#else\n        for (int kh = (h1 + PH) % SH; kh < KH; kh += SH) {\n            const int h2 = (h1 + PH - kh) / SH;\n#endif\n            if (h2 < 0 || h2 >= H2) continue;\n\n#if OPTIMIZE && SH_EQUAL_1\n            for (int kw = 0; kw < KW; kw++) {\n                const int w2 = w1 + PW - kw;\n#else\n            for (int kw = (w1 + PW) % SW; kw < KW; kw += SW) {\n                const int w2 = (w1 + PW - kw) / SW;\n#endif\n                if (w2 < 0 || w2 >= W2) continue;\n\n#if OPTIMIZE && C1_DIVIDABLE_BY_4\n                col4[((((n * H2 + h2) * W2 + w2) * KH + kh) * KW + kw) * C1_4 + c1_4] = v4;\n#else\n                col[((((n * H2 + h2) * W2 + w2) * KH + kh) * KW + kw) * C1 + c1] = v;\n#endif\n            }\n        }\n    }\n\n\n#undef SH_EQUAL_1\n#undef SW_EQUAL_1\n#undef C1_DIVIDABLE_BY_4\n}\n\n\nkernel void sgemm_1fe1c908701210c37c7cdbeb4c16e81d8255a13579dd647fe858078f(const device float *weight_buffer[[buffer(0)]],\n                          device float *data_buffer[[buffer(1)]],\n                          const device int * meta_buffer [[buffer(2)]],\n                          ushort index[[thread_index_in_threadgroup]],\n                          ushort2 group_position[[threadgroup_position_in_grid]])\n{\n#define TRANSPOSE_A 1\n#define TRANSPOSE_B 1\n#define M_DIVIDABLE_BY_64 1\n#define N_DIVIDABLE_BY_64 0\n#define K_DIVIDABLE_BY_8 0\n\n#if TRANSPOSE_A\n    #define A_STRIDE_K 1\n    #define A_STRIDE_M K\n#else\n    #define A_STRIDE_K M\n    #define A_STRIDE_M 1\n#endif\n\n#if TRANSPOSE_B\n    #define B_STRIDE_K N\n    #define B_STRIDE_N 1\n#else\n    #define B_STRIDE_K 1\n    #define B_STRIDE_N K\n#endif\n\n#define WITH_BIAS 1\n#define HAS_INLINE 1\n\n\n#if K_DIVIDABLE_BY_8 && M_DIVIDABLE_BY_64  && N_DIVIDABLE_BY_64 && !TRANSPOSE_A && TRANSPOSE_B && OPTIMIZE\n    const device float4 *load_target4 = (index & 32) \n        ? (const device float4 *)(weight_buffer + meta_buffer[1]) \n        : (const device float4 *)(data_buffer + meta_buffer[0]);\n#else\n    const device float *load_target = (index & 32) \n        ? (weight_buffer + meta_buffer[1]) \n        : (data_buffer + meta_buffer[0]);\n#endif\n\n    const int M = meta_buffer[4];\n    const int N = meta_buffer[5];\n\n    const int K = meta_buffer[6];\n\n    threadgroup float4 shared4[32 * 8 * 2];\n\n    const int stride_k = (index & 32) ? B_STRIDE_K : A_STRIDE_K;\n    const int stride_mn = (index & 32) ? B_STRIDE_N : A_STRIDE_M;\n\n    const int m_offset = index & 7;\n    const int n_offset = index >> 3;\n\n    const int mn_load_offset = ((index & 32) ? group_position.y : group_position.x) * 64 + (index & 15) * 4;\n    const int k_load_offset = ((index & 16) ? 1 : 0);\n\n    int track0 = mn_load_offset * stride_mn + (k_load_offset + 0) * stride_k;\n    int track2 = track0 + 2 * stride_k;\n    int track4 = track0 + 4 * stride_k;\n    int track6 = track0 + 6 * stride_k;\n\n#if !OPTIMIZE || !M_DIVIDABLE_BY_64 || !N_DIVIDABLE_BY_64\n    const int max_MN = (index & 32) ? N : M;\n#endif\n\n    int shared_offset4 = ((index & 32) ? 16 : 0) + k_load_offset * 32 + (index & 15);\n    int read_A_offset4 = m_offset * 2;\n    int read_B_offset4 = n_offset * 2 + 16;\n\n    float4 result[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    int k = 0;\n\n    while (k < K)\n    {\n        {\n#if OPTIMIZE && K_DIVIDABLE_BY_8\n    #if OPTIMIZE && M_DIVIDABLE_BY_64 && N_DIVIDABLE_BY_64\n        #if OPTIMIZE && !TRANSPOSE_A && TRANSPOSE_B\n            shared4[shared_offset4 + 32 * 0] = load_target4[track0 >> 2];\n            shared4[shared_offset4 + 32 * 2] = load_target4[track2 >> 2];\n            shared4[shared_offset4 + 32 * 4] = load_target4[track4 >> 2];\n            shared4[shared_offset4 + 32 * 6] = load_target4[track6 >> 2];\n        #else\n            shared4[shared_offset4 + 32 * 0] = float4(\n                load_target[track0 + stride_mn * 0],\n                load_target[track0 + stride_mn * 1],\n                load_target[track0 + stride_mn * 2],\n                load_target[track0 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 2] = float4(\n                load_target[track2 + stride_mn * 0],\n                load_target[track2 + stride_mn * 1],\n                load_target[track2 + stride_mn * 2],\n                load_target[track2 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 4] = float4(\n                load_target[track4 + stride_mn * 0],\n                load_target[track4 + stride_mn * 1],\n                load_target[track4 + stride_mn * 2],\n                load_target[track4 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 6] = float4(\n                load_target[track6 + stride_mn * 0],\n                load_target[track6 + stride_mn * 1],\n                load_target[track6 + stride_mn * 2],\n                load_target[track6 + stride_mn * 3]\n            ); \n        #endif\n    #else\n            shared4[shared_offset4 + 32 * 0] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track0 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track0 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track0 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track0 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 2] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track2 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track2 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track2 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track2 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 4] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track4 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track4 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track4 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track4 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 6] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track6 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track6 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track6 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track6 + stride_mn * 3]\n            ); \n    #endif\n\n            k += 8;\n#else\n    #if OPTIMIZE && M_DIVIDABLE_BY_64 && N_DIVIDABLE_BY_64\n            shared4[shared_offset4 + 32 * 0] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 2] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 4] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 6] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 3]\n            ); \n            k += 2;\n    #else\n            shared4[shared_offset4 + 32 * 0] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track0 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track0 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track0 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track0 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 2] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track2 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track2 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track2 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track2 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 4] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track4 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track4 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track4 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track4 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 6] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track6 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track6 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track6 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track6 + stride_mn * 3]\n            ); \n            k += 2;\n    #endif\n#endif\n        }\n\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n\n        {\n            for (int k_sub = 0; k_sub < 8; k_sub++)\n            {\n                float4 a00 = shared4[32 * k_sub + read_A_offset4 + 0];\n                float4 a01 = shared4[32 * k_sub + read_A_offset4 + 1];\n                float4 b00 = shared4[32 * k_sub + read_B_offset4 + 0];\n                float4 b01 = shared4[32 * k_sub + read_B_offset4 + 1];\n\n                result[4][0]  += b00[0] * a00[2];\n                result[4][1]  += b00[1] * a00[2];\n                result[0][1]  += b00[1] * a00[0];\n                result[0][0]  += b00[0] * a00[0];\n                result[6][0]  += b00[0] * a00[3];\n                result[6][1]  += b00[1] * a00[3];\n                result[2][1]  += b00[1] * a00[1];\n                result[2][0]  += b00[0] * a00[1];\n                result[12][0] += b00[0] * a01[2];\n                result[12][1] += b00[1] * a01[2];\n                result[8][1]  += b00[1] * a01[0];\n                result[8][0]  += b00[0] * a01[0];\n                result[14][0] += b00[0] * a01[3];\n                result[14][1] += b00[1] * a01[3];\n                result[10][1] += b00[1] * a01[1];\n                result[10][0] += b00[0] * a01[1];\n\n                result[14][2] += b00[2] * a01[3];\n                result[14][3] += b00[3] * a01[3];\n                result[10][3] += b00[3] * a01[1];\n                result[10][2] += b00[2] * a01[1];\n                result[12][2] += b00[2] * a01[2];\n                result[12][3] += b00[3] * a01[2];\n                result[8][3]  += b00[3] * a01[0];\n                result[8][2]  += b00[2] * a01[0];\n                result[6][2]  += b00[2] * a00[3];\n                result[6][3]  += b00[3] * a00[3];\n                result[2][3]  += b00[3] * a00[1];\n                result[2][2]  += b00[2] * a00[1];\n                result[4][2]  += b00[2] * a00[2];\n                result[4][3]  += b00[3] * a00[2];\n                result[0][3]  += b00[3] * a00[0];\n                result[0][2]  += b00[2] * a00[0];\n\n                result[5][0]  += b01[0] * a00[2];\n                result[5][1]  += b01[1] * a00[2];\n                result[1][1]  += b01[1] * a00[0];\n                result[1][0]  += b01[0] * a00[0];\n                result[7][0]  += b01[0] * a00[3];\n                result[7][1]  += b01[1] * a00[3];\n                result[3][1]  += b01[1] * a00[1];\n                result[3][0]  += b01[0] * a00[1];\n                result[13][0] += b01[0] * a01[2];\n                result[13][1] += b01[1] * a01[2];\n                result[9][1]  += b01[1] * a01[0];\n                result[9][0]  += b01[0] * a01[0];\n                result[15][0] += b01[0] * a01[3];\n                result[15][1] += b01[1] * a01[3];\n                result[11][1] += b01[1] * a01[1];\n                result[11][0] += b01[0] * a01[1];\n\n                result[15][2] += b01[2] * a01[3];\n                result[15][3] += b01[3] * a01[3];\n                result[11][3] += b01[3] * a01[1];\n                result[11][2] += b01[2] * a01[1];\n                result[13][2] += b01[2] * a01[2];\n                result[13][3] += b01[3] * a01[2];\n                result[9][3]  += b01[3] * a01[0];\n                result[9][2]  += b01[2] * a01[0];\n                result[7][2]  += b01[2] * a00[3];\n                result[7][3]  += b01[3] * a00[3];\n                result[3][3]  += b01[3] * a00[1];\n                result[3][2]  += b01[2] * a00[1];\n                result[5][2]  += b01[2] * a00[2];\n                result[5][3]  += b01[3] * a00[2];\n                result[1][3]  += b01[3] * a00[0];\n                result[1][2]  += b01[2] * a00[0];\n            }\n        }\n\n        shared_offset4 ^= 32 * 8;\n        read_A_offset4 ^= 32 * 8;\n        read_B_offset4 ^= 32 * 8;\n        track0 += stride_k * 8;\n        track2 += stride_k * 8;\n        track4 += stride_k * 8;\n        track6 += stride_k * 8;\n    }\n\n    {\n    \n#if OPTIMIZE && N_DIVIDABLE_BY_64\n    #if WITH_BIAS\n        float4 b[2];\n        const device float4 *bias4 = (const device float4 *)(weight_buffer + meta_buffer[3]);\n        b[0] = bias4[group_position.y * 16 + n_offset * 2 + 0];\n        b[1] = bias4[group_position.y * 16 + n_offset * 2 + 1];\n    #endif\n    \n        device float4 *C4 = (device float4 *)(data_buffer + meta_buffer[2]);\n        const int N4 = N >> 2;\n        int m = group_position.x * 64 + m_offset * 8;\n        for (int m_sub = 0; m_sub < 8; m_sub++)\n        {\n\n    #if !M_DIVIDABLE_BY_64\n            if (m >= M) continue;\n    #endif\n\n            const int n = group_position.y * 16 + n_offset * 2;\n            float4 result0 = result[m_sub * 2 + 0];\n            float4 result1 = result[m_sub * 2 + 1];\n\n    #if WITH_BIAS\n            result0 += b[0];\n            result1 += b[1];\n    #endif\n\n    #if HAS_INLINE\n            result0[0] = (result0[0]>0?result0[0]:(exp(result0[0])-1));\n            result0[1] = (result0[1]>0?result0[1]:(exp(result0[1])-1));\n            result0[2] = (result0[2]>0?result0[2]:(exp(result0[2])-1));\n            result0[3] = (result0[3]>0?result0[3]:(exp(result0[3])-1));\n            result1[0] = (result1[0]>0?result1[0]:(exp(result1[0])-1));\n            result1[1] = (result1[1]>0?result1[1]:(exp(result1[1])-1));\n            result1[2] = (result1[2]>0?result1[2]:(exp(result1[2])-1));\n            result1[3] = (result1[3]>0?result1[3]:(exp(result1[3])-1));\n    #endif\n\n            C4[m * N4 + n + 0] = result0;\n            C4[m * N4 + n + 1] = result1;\n            \n            m++;\n        }\n#else\n    #if WITH_BIAS\n        const device float *bias = weight_buffer + meta_buffer[3];\n        float b[8];\n        for (int n_sub = 0; n_sub < 8; n_sub++)\n        {\n            b[n_sub] = (group_position.y * 64 + n_offset * 8 + n_sub < N)\n                ? bias[group_position.y * 64 + n_offset * 8 + n_sub]\n                : 0;\n        }\n    #endif\n\n        device float *C = data_buffer + meta_buffer[2];\n        int m = group_position.x * 64 + m_offset * 8;\n        for (int m_sub = 0; m_sub < 8; m_sub++)\n        {\n            int n = group_position.y * 64 + n_offset * 8;\n\n            for (int n_sub1 = 0; n_sub1 < 2; n_sub1++)\n            {\n                for (int n_sub2 = 0; n_sub2 < 4; n_sub2++)\n                {\n\n    #if WITH_BIAS\n        #if OPTIMIZE && M_DIVIDABLE_BY_64\n                    (         n < N) ? (C[m * N + n] = (result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2]>0?result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2]:(exp(result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2])-1))) : 0;\n        #else\n                    (m < M && n < N) ? (C[m * N + n] = (result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2]>0?result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2]:(exp(result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2])-1))) : 0;\n        #endif\n    #else\n        #if OPTIMIZE && M_DIVIDABLE_BY_64\n                    (         n < N) ? (C[m * N + n] = (result[m_sub * 2 + n_sub1][n_sub2]>0?result[m_sub * 2 + n_sub1][n_sub2]:(exp(result[m_sub * 2 + n_sub1][n_sub2])-1))) : 0;\n        #else\n                    (m < M && n < N) ? (C[m * N + n] = (result[m_sub * 2 + n_sub1][n_sub2]>0?result[m_sub * 2 + n_sub1][n_sub2]:(exp(result[m_sub * 2 + n_sub1][n_sub2])-1))) : 0;\n        #endif\n    #endif\n                    n++;\n                }\n            }\n            \n            m++;\n        }\n#endif\n\n    }\n\n\n#undef M_DIVIDABLE_BY_64\n#undef N_DIVIDABLE_BY_64\n#undef K_DIVIDABLE_BY_8\n#undef TRANSPOSE_A\n#undef TRANSPOSE_B\n#undef A_STRIDE_K\n#undef B_STRIDE_K\n#undef A_STRIDE_M\n#undef A_STRIDE_M\n#undef WITH_BIAS\n#undef HAS_INLINE\n}\n\n\nkernel void axiswisescale_eb0047e7bd89ea7055f72ebafeb790e891bb2505194856bd8fe5e84d(const device float *weight_buffer[[buffer(0)]],\n                          device float *data_buffer[[buffer(1)]],\n                          const device int * meta_buffer [[buffer(2)]],\n                          uint index[[thread_position_in_grid]],\n                          uint num_threads[[threads_per_grid]])\n{\n    const device float *X = data_buffer + meta_buffer[0];\n    device float *Y = data_buffer + meta_buffer[1];\n    const device float *S = weight_buffer + meta_buffer[2];\n    const int N = meta_buffer[3];\n    const int C = meta_buffer[4];\n  \n    for (int gid = index; gid < N; gid += num_threads) {\n        int c = gid % C;\n\n        float result = X[gid] * S[c];\n\n        Y[gid] = result;\n    }\n}\n\n\nkernel void axiswisebias_6be2df9cf1526331046f94fd7a124df8004489b3081b9db2c7e0fa03(const device float *weight_buffer[[buffer(0)]],\n                          device float *data_buffer[[buffer(1)]],\n                          const device int * meta_buffer [[buffer(2)]],\n                          uint index[[thread_position_in_grid]],\n                          uint num_threads[[threads_per_grid]])\n{\n    const device float *X = data_buffer + meta_buffer[0];\n    device float *Y = data_buffer + meta_buffer[1];\n    const device float *B = weight_buffer + meta_buffer[2];\n    const int N = meta_buffer[3];\n    const int C = meta_buffer[4];\n  \n    for (int gid = index; gid < N * C; gid += num_threads) {\n        int c = gid % C;\n        int n = gid / C;\n\n        float result = X[gid] + B[c];\n        Y[n * C + c] = result;\n    }\n}\n\n\nkernel void im2col_094f568353bf9de7c01e0b777df297bf4afc40425d719b9b676a1d9f(const device float *param_buffer[[buffer(0)]],\n                          device float *data_buffer[[buffer(1)]],\n                          const device int * meta_buffer [[buffer(2)]],\n                          ushort index_thread[[thread_position_in_threadgroup]],\n                          ushort index_group[[threadgroup_position_in_grid]])\n{\n#define SH_EQUAL_1 0\n#define SW_EQUAL_1 0\n#define C1_DIVIDABLE_BY_4 1\n\n\n#if OPTIMIZE && C1_DIVIDABLE_BY_4\n    const device float4 *im4 = (const device float4 *)(data_buffer + meta_buffer[0]);\n    device float4 *col4 = (device float4 *)(data_buffer + meta_buffer[1]);\n    const int C1_4 = (meta_buffer[3]) >> 2;\n#else\n    const device float *im = data_buffer + meta_buffer[0];\n    device float *col = data_buffer + meta_buffer[1];\n    const int C1 = meta_buffer[3];\n#endif\n\n    // const int N = meta_buffer[2];\n    const int H1 = meta_buffer[4];\n    const int W1 = meta_buffer[5];\n    const int H2 = meta_buffer[6];\n    const int W2 = meta_buffer[7];\n    const int KH = meta_buffer[8];\n    const int KW = meta_buffer[9];\n    const int PH = meta_buffer[12];\n    const int PW = meta_buffer[13];\n\n#if !OPTIMIZE || !SH_EQUAL_1\n    const int SH = meta_buffer[10];\n#endif\n\n#if !OPTIMIZE || !SW_EQUAL_1\n    const int SW = meta_buffer[11];\n#endif\n\n    const int H1P = H1 + 2 * PH;\n    const int W1P = W1 + 2 * PW;\n\n    const int w1 = (index_group % W1P) - PW;\n    const int h1 = (index_group / W1P % H1P) - PH;\n    const int  n = index_group / W1P / H1P;\n\n#if OPTIMIZE && C1_DIVIDABLE_BY_4\n    for (int c1_4 = index_thread; c1_4 < C1_4; c1_4 += 64) {\n        const float4 v4 = (h1 < 0 || h1 >= H1 || w1 < 0 || w1 >= W1) ? 0 : im4[((n * H1 + h1) * W1 + w1) * C1_4 + c1_4];\n#else\n    for (int c1 = index_thread; c1 < C1; c1 += 64) {\n        const float v = (h1 < 0 || h1 >= H1 || w1 < 0 || w1 >= W1) ? 0 : im[((n * H1 + h1) * W1 + w1) * C1 + c1];\n#endif\n\n#if OPTIMIZE && SH_EQUAL_1\n        for (int kh = 0; kh < KH; kh++) {\n            const int h2 = h1 + PH - kh;\n#else\n        for (int kh = (h1 + PH) % SH; kh < KH; kh += SH) {\n            const int h2 = (h1 + PH - kh) / SH;\n#endif\n            if (h2 < 0 || h2 >= H2) continue;\n\n#if OPTIMIZE && SH_EQUAL_1\n            for (int kw = 0; kw < KW; kw++) {\n                const int w2 = w1 + PW - kw;\n#else\n            for (int kw = (w1 + PW) % SW; kw < KW; kw += SW) {\n                const int w2 = (w1 + PW - kw) / SW;\n#endif\n                if (w2 < 0 || w2 >= W2) continue;\n\n#if OPTIMIZE && C1_DIVIDABLE_BY_4\n                col4[((((n * H2 + h2) * W2 + w2) * KH + kh) * KW + kw) * C1_4 + c1_4] = v4;\n#else\n                col[((((n * H2 + h2) * W2 + w2) * KH + kh) * KW + kw) * C1 + c1] = v;\n#endif\n            }\n        }\n    }\n\n\n#undef SH_EQUAL_1\n#undef SW_EQUAL_1\n#undef C1_DIVIDABLE_BY_4\n}\n\n\nkernel void sgemm_7bb39dea9313ec8d8e4c2c50047d68337ba2b05833316191856f2f17(const device float *weight_buffer[[buffer(0)]],\n                          device float *data_buffer[[buffer(1)]],\n                          const device int * meta_buffer [[buffer(2)]],\n                          ushort index[[thread_index_in_threadgroup]],\n                          ushort2 group_position[[threadgroup_position_in_grid]])\n{\n#define TRANSPOSE_A 1\n#define TRANSPOSE_B 1\n#define M_DIVIDABLE_BY_64 1\n#define N_DIVIDABLE_BY_64 1\n#define K_DIVIDABLE_BY_8 1\n\n#if TRANSPOSE_A\n    #define A_STRIDE_K 1\n    #define A_STRIDE_M K\n#else\n    #define A_STRIDE_K M\n    #define A_STRIDE_M 1\n#endif\n\n#if TRANSPOSE_B\n    #define B_STRIDE_K N\n    #define B_STRIDE_N 1\n#else\n    #define B_STRIDE_K 1\n    #define B_STRIDE_N K\n#endif\n\n#define WITH_BIAS 1\n#define HAS_INLINE 1\n\n\n#if K_DIVIDABLE_BY_8 && M_DIVIDABLE_BY_64  && N_DIVIDABLE_BY_64 && !TRANSPOSE_A && TRANSPOSE_B && OPTIMIZE\n    const device float4 *load_target4 = (index & 32) \n        ? (const device float4 *)(weight_buffer + meta_buffer[1]) \n        : (const device float4 *)(data_buffer + meta_buffer[0]);\n#else\n    const device float *load_target = (index & 32) \n        ? (weight_buffer + meta_buffer[1]) \n        : (data_buffer + meta_buffer[0]);\n#endif\n\n    const int M = meta_buffer[4];\n    const int N = meta_buffer[5];\n\n    const int K = meta_buffer[6];\n\n    threadgroup float4 shared4[32 * 8 * 2];\n\n    const int stride_k = (index & 32) ? B_STRIDE_K : A_STRIDE_K;\n    const int stride_mn = (index & 32) ? B_STRIDE_N : A_STRIDE_M;\n\n    const int m_offset = index & 7;\n    const int n_offset = index >> 3;\n\n    const int mn_load_offset = ((index & 32) ? group_position.y : group_position.x) * 64 + (index & 15) * 4;\n    const int k_load_offset = ((index & 16) ? 1 : 0);\n\n    int track0 = mn_load_offset * stride_mn + (k_load_offset + 0) * stride_k;\n    int track2 = track0 + 2 * stride_k;\n    int track4 = track0 + 4 * stride_k;\n    int track6 = track0 + 6 * stride_k;\n\n#if !OPTIMIZE || !M_DIVIDABLE_BY_64 || !N_DIVIDABLE_BY_64\n    const int max_MN = (index & 32) ? N : M;\n#endif\n\n    int shared_offset4 = ((index & 32) ? 16 : 0) + k_load_offset * 32 + (index & 15);\n    int read_A_offset4 = m_offset * 2;\n    int read_B_offset4 = n_offset * 2 + 16;\n\n    float4 result[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    int k = 0;\n\n    while (k < K)\n    {\n        {\n#if OPTIMIZE && K_DIVIDABLE_BY_8\n    #if OPTIMIZE && M_DIVIDABLE_BY_64 && N_DIVIDABLE_BY_64\n        #if OPTIMIZE && !TRANSPOSE_A && TRANSPOSE_B\n            shared4[shared_offset4 + 32 * 0] = load_target4[track0 >> 2];\n            shared4[shared_offset4 + 32 * 2] = load_target4[track2 >> 2];\n            shared4[shared_offset4 + 32 * 4] = load_target4[track4 >> 2];\n            shared4[shared_offset4 + 32 * 6] = load_target4[track6 >> 2];\n        #else\n            shared4[shared_offset4 + 32 * 0] = float4(\n                load_target[track0 + stride_mn * 0],\n                load_target[track0 + stride_mn * 1],\n                load_target[track0 + stride_mn * 2],\n                load_target[track0 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 2] = float4(\n                load_target[track2 + stride_mn * 0],\n                load_target[track2 + stride_mn * 1],\n                load_target[track2 + stride_mn * 2],\n                load_target[track2 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 4] = float4(\n                load_target[track4 + stride_mn * 0],\n                load_target[track4 + stride_mn * 1],\n                load_target[track4 + stride_mn * 2],\n                load_target[track4 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 6] = float4(\n                load_target[track6 + stride_mn * 0],\n                load_target[track6 + stride_mn * 1],\n                load_target[track6 + stride_mn * 2],\n                load_target[track6 + stride_mn * 3]\n            ); \n        #endif\n    #else\n            shared4[shared_offset4 + 32 * 0] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track0 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track0 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track0 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track0 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 2] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track2 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track2 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track2 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track2 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 4] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track4 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track4 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track4 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track4 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 6] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track6 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track6 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track6 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track6 + stride_mn * 3]\n            ); \n    #endif\n\n            k += 8;\n#else\n    #if OPTIMIZE && M_DIVIDABLE_BY_64 && N_DIVIDABLE_BY_64\n            shared4[shared_offset4 + 32 * 0] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 2] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 4] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 6] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 3]\n            ); \n            k += 2;\n    #else\n            shared4[shared_offset4 + 32 * 0] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track0 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track0 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track0 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track0 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 2] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track2 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track2 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track2 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track2 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 4] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track4 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track4 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track4 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track4 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 6] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track6 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track6 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track6 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track6 + stride_mn * 3]\n            ); \n            k += 2;\n    #endif\n#endif\n        }\n\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n\n        {\n            for (int k_sub = 0; k_sub < 8; k_sub++)\n            {\n                float4 a00 = shared4[32 * k_sub + read_A_offset4 + 0];\n                float4 a01 = shared4[32 * k_sub + read_A_offset4 + 1];\n                float4 b00 = shared4[32 * k_sub + read_B_offset4 + 0];\n                float4 b01 = shared4[32 * k_sub + read_B_offset4 + 1];\n\n                result[4][0]  += b00[0] * a00[2];\n                result[4][1]  += b00[1] * a00[2];\n                result[0][1]  += b00[1] * a00[0];\n                result[0][0]  += b00[0] * a00[0];\n                result[6][0]  += b00[0] * a00[3];\n                result[6][1]  += b00[1] * a00[3];\n                result[2][1]  += b00[1] * a00[1];\n                result[2][0]  += b00[0] * a00[1];\n                result[12][0] += b00[0] * a01[2];\n                result[12][1] += b00[1] * a01[2];\n                result[8][1]  += b00[1] * a01[0];\n                result[8][0]  += b00[0] * a01[0];\n                result[14][0] += b00[0] * a01[3];\n                result[14][1] += b00[1] * a01[3];\n                result[10][1] += b00[1] * a01[1];\n                result[10][0] += b00[0] * a01[1];\n\n                result[14][2] += b00[2] * a01[3];\n                result[14][3] += b00[3] * a01[3];\n                result[10][3] += b00[3] * a01[1];\n                result[10][2] += b00[2] * a01[1];\n                result[12][2] += b00[2] * a01[2];\n                result[12][3] += b00[3] * a01[2];\n                result[8][3]  += b00[3] * a01[0];\n                result[8][2]  += b00[2] * a01[0];\n                result[6][2]  += b00[2] * a00[3];\n                result[6][3]  += b00[3] * a00[3];\n                result[2][3]  += b00[3] * a00[1];\n                result[2][2]  += b00[2] * a00[1];\n                result[4][2]  += b00[2] * a00[2];\n                result[4][3]  += b00[3] * a00[2];\n                result[0][3]  += b00[3] * a00[0];\n                result[0][2]  += b00[2] * a00[0];\n\n                result[5][0]  += b01[0] * a00[2];\n                result[5][1]  += b01[1] * a00[2];\n                result[1][1]  += b01[1] * a00[0];\n                result[1][0]  += b01[0] * a00[0];\n                result[7][0]  += b01[0] * a00[3];\n                result[7][1]  += b01[1] * a00[3];\n                result[3][1]  += b01[1] * a00[1];\n                result[3][0]  += b01[0] * a00[1];\n                result[13][0] += b01[0] * a01[2];\n                result[13][1] += b01[1] * a01[2];\n                result[9][1]  += b01[1] * a01[0];\n                result[9][0]  += b01[0] * a01[0];\n                result[15][0] += b01[0] * a01[3];\n                result[15][1] += b01[1] * a01[3];\n                result[11][1] += b01[1] * a01[1];\n                result[11][0] += b01[0] * a01[1];\n\n                result[15][2] += b01[2] * a01[3];\n                result[15][3] += b01[3] * a01[3];\n                result[11][3] += b01[3] * a01[1];\n                result[11][2] += b01[2] * a01[1];\n                result[13][2] += b01[2] * a01[2];\n                result[13][3] += b01[3] * a01[2];\n                result[9][3]  += b01[3] * a01[0];\n                result[9][2]  += b01[2] * a01[0];\n                result[7][2]  += b01[2] * a00[3];\n                result[7][3]  += b01[3] * a00[3];\n                result[3][3]  += b01[3] * a00[1];\n                result[3][2]  += b01[2] * a00[1];\n                result[5][2]  += b01[2] * a00[2];\n                result[5][3]  += b01[3] * a00[2];\n                result[1][3]  += b01[3] * a00[0];\n                result[1][2]  += b01[2] * a00[0];\n            }\n        }\n\n        shared_offset4 ^= 32 * 8;\n        read_A_offset4 ^= 32 * 8;\n        read_B_offset4 ^= 32 * 8;\n        track0 += stride_k * 8;\n        track2 += stride_k * 8;\n        track4 += stride_k * 8;\n        track6 += stride_k * 8;\n    }\n\n    {\n    \n#if OPTIMIZE && N_DIVIDABLE_BY_64\n    #if WITH_BIAS\n        float4 b[2];\n        const device float4 *bias4 = (const device float4 *)(weight_buffer + meta_buffer[3]);\n        b[0] = bias4[group_position.y * 16 + n_offset * 2 + 0];\n        b[1] = bias4[group_position.y * 16 + n_offset * 2 + 1];\n    #endif\n    \n        device float4 *C4 = (device float4 *)(data_buffer + meta_buffer[2]);\n        const int N4 = N >> 2;\n        int m = group_position.x * 64 + m_offset * 8;\n        for (int m_sub = 0; m_sub < 8; m_sub++)\n        {\n\n    #if !M_DIVIDABLE_BY_64\n            if (m >= M) continue;\n    #endif\n\n            const int n = group_position.y * 16 + n_offset * 2;\n            float4 result0 = result[m_sub * 2 + 0];\n            float4 result1 = result[m_sub * 2 + 1];\n\n    #if WITH_BIAS\n            result0 += b[0];\n            result1 += b[1];\n    #endif\n\n    #if HAS_INLINE\n            result0[0] = (result0[0]>0?result0[0]:(exp(result0[0])-1));\n            result0[1] = (result0[1]>0?result0[1]:(exp(result0[1])-1));\n            result0[2] = (result0[2]>0?result0[2]:(exp(result0[2])-1));\n            result0[3] = (result0[3]>0?result0[3]:(exp(result0[3])-1));\n            result1[0] = (result1[0]>0?result1[0]:(exp(result1[0])-1));\n            result1[1] = (result1[1]>0?result1[1]:(exp(result1[1])-1));\n            result1[2] = (result1[2]>0?result1[2]:(exp(result1[2])-1));\n            result1[3] = (result1[3]>0?result1[3]:(exp(result1[3])-1));\n    #endif\n\n            C4[m * N4 + n + 0] = result0;\n            C4[m * N4 + n + 1] = result1;\n            \n            m++;\n        }\n#else\n    #if WITH_BIAS\n        const device float *bias = weight_buffer + meta_buffer[3];\n        float b[8];\n        for (int n_sub = 0; n_sub < 8; n_sub++)\n        {\n            b[n_sub] = (group_position.y * 64 + n_offset * 8 + n_sub < N)\n                ? bias[group_position.y * 64 + n_offset * 8 + n_sub]\n                : 0;\n        }\n    #endif\n\n        device float *C = data_buffer + meta_buffer[2];\n        int m = group_position.x * 64 + m_offset * 8;\n        for (int m_sub = 0; m_sub < 8; m_sub++)\n        {\n            int n = group_position.y * 64 + n_offset * 8;\n\n            for (int n_sub1 = 0; n_sub1 < 2; n_sub1++)\n            {\n                for (int n_sub2 = 0; n_sub2 < 4; n_sub2++)\n                {\n\n    #if WITH_BIAS\n        #if OPTIMIZE && M_DIVIDABLE_BY_64\n                    (         n < N) ? (C[m * N + n] = (result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2]>0?result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2]:(exp(result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2])-1))) : 0;\n        #else\n                    (m < M && n < N) ? (C[m * N + n] = (result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2]>0?result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2]:(exp(result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2])-1))) : 0;\n        #endif\n    #else\n        #if OPTIMIZE && M_DIVIDABLE_BY_64\n                    (         n < N) ? (C[m * N + n] = (result[m_sub * 2 + n_sub1][n_sub2]>0?result[m_sub * 2 + n_sub1][n_sub2]:(exp(result[m_sub * 2 + n_sub1][n_sub2])-1))) : 0;\n        #else\n                    (m < M && n < N) ? (C[m * N + n] = (result[m_sub * 2 + n_sub1][n_sub2]>0?result[m_sub * 2 + n_sub1][n_sub2]:(exp(result[m_sub * 2 + n_sub1][n_sub2])-1))) : 0;\n        #endif\n    #endif\n                    n++;\n                }\n            }\n            \n            m++;\n        }\n#endif\n\n    }\n\n\n#undef M_DIVIDABLE_BY_64\n#undef N_DIVIDABLE_BY_64\n#undef K_DIVIDABLE_BY_8\n#undef TRANSPOSE_A\n#undef TRANSPOSE_B\n#undef A_STRIDE_K\n#undef B_STRIDE_K\n#undef A_STRIDE_M\n#undef A_STRIDE_M\n#undef WITH_BIAS\n#undef HAS_INLINE\n}\n\n\nkernel void im2col_884fd9f360ddda90bf2cf46891d08c8646216406a876e59098baf6e0(const device float *param_buffer[[buffer(0)]],\n                          device float *data_buffer[[buffer(1)]],\n                          const device int * meta_buffer [[buffer(2)]],\n                          ushort index_thread[[thread_position_in_threadgroup]],\n                          ushort index_group[[threadgroup_position_in_grid]])\n{\n#define SH_EQUAL_1 1\n#define SW_EQUAL_1 1\n#define C1_DIVIDABLE_BY_4 1\n\n\n#if OPTIMIZE && C1_DIVIDABLE_BY_4\n    const device float4 *im4 = (const device float4 *)(data_buffer + meta_buffer[0]);\n    device float4 *col4 = (device float4 *)(data_buffer + meta_buffer[1]);\n    const int C1_4 = (meta_buffer[3]) >> 2;\n#else\n    const device float *im = data_buffer + meta_buffer[0];\n    device float *col = data_buffer + meta_buffer[1];\n    const int C1 = meta_buffer[3];\n#endif\n\n    // const int N = meta_buffer[2];\n    const int H1 = meta_buffer[4];\n    const int W1 = meta_buffer[5];\n    const int H2 = meta_buffer[6];\n    const int W2 = meta_buffer[7];\n    const int KH = meta_buffer[8];\n    const int KW = meta_buffer[9];\n    const int PH = meta_buffer[12];\n    const int PW = meta_buffer[13];\n\n#if !OPTIMIZE || !SH_EQUAL_1\n    const int SH = meta_buffer[10];\n#endif\n\n#if !OPTIMIZE || !SW_EQUAL_1\n    const int SW = meta_buffer[11];\n#endif\n\n    const int H1P = H1 + 2 * PH;\n    const int W1P = W1 + 2 * PW;\n\n    const int w1 = (index_group % W1P) - PW;\n    const int h1 = (index_group / W1P % H1P) - PH;\n    const int  n = index_group / W1P / H1P;\n\n#if OPTIMIZE && C1_DIVIDABLE_BY_4\n    for (int c1_4 = index_thread; c1_4 < C1_4; c1_4 += 64) {\n        const float4 v4 = (h1 < 0 || h1 >= H1 || w1 < 0 || w1 >= W1) ? 0 : im4[((n * H1 + h1) * W1 + w1) * C1_4 + c1_4];\n#else\n    for (int c1 = index_thread; c1 < C1; c1 += 64) {\n        const float v = (h1 < 0 || h1 >= H1 || w1 < 0 || w1 >= W1) ? 0 : im[((n * H1 + h1) * W1 + w1) * C1 + c1];\n#endif\n\n#if OPTIMIZE && SH_EQUAL_1\n        for (int kh = 0; kh < KH; kh++) {\n            const int h2 = h1 + PH - kh;\n#else\n        for (int kh = (h1 + PH) % SH; kh < KH; kh += SH) {\n            const int h2 = (h1 + PH - kh) / SH;\n#endif\n            if (h2 < 0 || h2 >= H2) continue;\n\n#if OPTIMIZE && SH_EQUAL_1\n            for (int kw = 0; kw < KW; kw++) {\n                const int w2 = w1 + PW - kw;\n#else\n            for (int kw = (w1 + PW) % SW; kw < KW; kw += SW) {\n                const int w2 = (w1 + PW - kw) / SW;\n#endif\n                if (w2 < 0 || w2 >= W2) continue;\n\n#if OPTIMIZE && C1_DIVIDABLE_BY_4\n                col4[((((n * H2 + h2) * W2 + w2) * KH + kh) * KW + kw) * C1_4 + c1_4] = v4;\n#else\n                col[((((n * H2 + h2) * W2 + w2) * KH + kh) * KW + kw) * C1 + c1] = v;\n#endif\n            }\n        }\n    }\n\n\n#undef SH_EQUAL_1\n#undef SW_EQUAL_1\n#undef C1_DIVIDABLE_BY_4\n}\n\n\nkernel void sgemm_d2120e4054f06f47109f63cd135af4cf5af06fd36eb3fc1661c88712(const device float *weight_buffer[[buffer(0)]],\n                          device float *data_buffer[[buffer(1)]],\n                          const device int * meta_buffer [[buffer(2)]],\n                          ushort index[[thread_index_in_threadgroup]],\n                          ushort2 group_position[[threadgroup_position_in_grid]])\n{\n#define TRANSPOSE_A 1\n#define TRANSPOSE_B 1\n#define M_DIVIDABLE_BY_64 1\n#define N_DIVIDABLE_BY_64 1\n#define K_DIVIDABLE_BY_8 1\n\n#if TRANSPOSE_A\n    #define A_STRIDE_K 1\n    #define A_STRIDE_M K\n#else\n    #define A_STRIDE_K M\n    #define A_STRIDE_M 1\n#endif\n\n#if TRANSPOSE_B\n    #define B_STRIDE_K N\n    #define B_STRIDE_N 1\n#else\n    #define B_STRIDE_K 1\n    #define B_STRIDE_N K\n#endif\n\n#define WITH_BIAS 1\n#define HAS_INLINE 1\n\n\n#if K_DIVIDABLE_BY_8 && M_DIVIDABLE_BY_64  && N_DIVIDABLE_BY_64 && !TRANSPOSE_A && TRANSPOSE_B && OPTIMIZE\n    const device float4 *load_target4 = (index & 32) \n        ? (const device float4 *)(weight_buffer + meta_buffer[1]) \n        : (const device float4 *)(data_buffer + meta_buffer[0]);\n#else\n    const device float *load_target = (index & 32) \n        ? (weight_buffer + meta_buffer[1]) \n        : (data_buffer + meta_buffer[0]);\n#endif\n\n    const int M = meta_buffer[4];\n    const int N = meta_buffer[5];\n\n    const int K = meta_buffer[6];\n\n    threadgroup float4 shared4[32 * 8 * 2];\n\n    const int stride_k = (index & 32) ? B_STRIDE_K : A_STRIDE_K;\n    const int stride_mn = (index & 32) ? B_STRIDE_N : A_STRIDE_M;\n\n    const int m_offset = index & 7;\n    const int n_offset = index >> 3;\n\n    const int mn_load_offset = ((index & 32) ? group_position.y : group_position.x) * 64 + (index & 15) * 4;\n    const int k_load_offset = ((index & 16) ? 1 : 0);\n\n    int track0 = mn_load_offset * stride_mn + (k_load_offset + 0) * stride_k;\n    int track2 = track0 + 2 * stride_k;\n    int track4 = track0 + 4 * stride_k;\n    int track6 = track0 + 6 * stride_k;\n\n#if !OPTIMIZE || !M_DIVIDABLE_BY_64 || !N_DIVIDABLE_BY_64\n    const int max_MN = (index & 32) ? N : M;\n#endif\n\n    int shared_offset4 = ((index & 32) ? 16 : 0) + k_load_offset * 32 + (index & 15);\n    int read_A_offset4 = m_offset * 2;\n    int read_B_offset4 = n_offset * 2 + 16;\n\n    float4 result[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    int k = 0;\n\n    while (k < K)\n    {\n        {\n#if OPTIMIZE && K_DIVIDABLE_BY_8\n    #if OPTIMIZE && M_DIVIDABLE_BY_64 && N_DIVIDABLE_BY_64\n        #if OPTIMIZE && !TRANSPOSE_A && TRANSPOSE_B\n            shared4[shared_offset4 + 32 * 0] = load_target4[track0 >> 2];\n            shared4[shared_offset4 + 32 * 2] = load_target4[track2 >> 2];\n            shared4[shared_offset4 + 32 * 4] = load_target4[track4 >> 2];\n            shared4[shared_offset4 + 32 * 6] = load_target4[track6 >> 2];\n        #else\n            shared4[shared_offset4 + 32 * 0] = float4(\n                load_target[track0 + stride_mn * 0],\n                load_target[track0 + stride_mn * 1],\n                load_target[track0 + stride_mn * 2],\n                load_target[track0 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 2] = float4(\n                load_target[track2 + stride_mn * 0],\n                load_target[track2 + stride_mn * 1],\n                load_target[track2 + stride_mn * 2],\n                load_target[track2 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 4] = float4(\n                load_target[track4 + stride_mn * 0],\n                load_target[track4 + stride_mn * 1],\n                load_target[track4 + stride_mn * 2],\n                load_target[track4 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 6] = float4(\n                load_target[track6 + stride_mn * 0],\n                load_target[track6 + stride_mn * 1],\n                load_target[track6 + stride_mn * 2],\n                load_target[track6 + stride_mn * 3]\n            ); \n        #endif\n    #else\n            shared4[shared_offset4 + 32 * 0] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track0 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track0 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track0 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track0 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 2] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track2 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track2 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track2 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track2 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 4] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track4 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track4 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track4 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track4 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 6] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track6 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track6 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track6 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track6 + stride_mn * 3]\n            ); \n    #endif\n\n            k += 8;\n#else\n    #if OPTIMIZE && M_DIVIDABLE_BY_64 && N_DIVIDABLE_BY_64\n            shared4[shared_offset4 + 32 * 0] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 2] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 4] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 6] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 3]\n            ); \n            k += 2;\n    #else\n            shared4[shared_offset4 + 32 * 0] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track0 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track0 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track0 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track0 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 2] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track2 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track2 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track2 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track2 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 4] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track4 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track4 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track4 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track4 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 6] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track6 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track6 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track6 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track6 + stride_mn * 3]\n            ); \n            k += 2;\n    #endif\n#endif\n        }\n\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n\n        {\n            for (int k_sub = 0; k_sub < 8; k_sub++)\n            {\n                float4 a00 = shared4[32 * k_sub + read_A_offset4 + 0];\n                float4 a01 = shared4[32 * k_sub + read_A_offset4 + 1];\n                float4 b00 = shared4[32 * k_sub + read_B_offset4 + 0];\n                float4 b01 = shared4[32 * k_sub + read_B_offset4 + 1];\n\n                result[4][0]  += b00[0] * a00[2];\n                result[4][1]  += b00[1] * a00[2];\n                result[0][1]  += b00[1] * a00[0];\n                result[0][0]  += b00[0] * a00[0];\n                result[6][0]  += b00[0] * a00[3];\n                result[6][1]  += b00[1] * a00[3];\n                result[2][1]  += b00[1] * a00[1];\n                result[2][0]  += b00[0] * a00[1];\n                result[12][0] += b00[0] * a01[2];\n                result[12][1] += b00[1] * a01[2];\n                result[8][1]  += b00[1] * a01[0];\n                result[8][0]  += b00[0] * a01[0];\n                result[14][0] += b00[0] * a01[3];\n                result[14][1] += b00[1] * a01[3];\n                result[10][1] += b00[1] * a01[1];\n                result[10][0] += b00[0] * a01[1];\n\n                result[14][2] += b00[2] * a01[3];\n                result[14][3] += b00[3] * a01[3];\n                result[10][3] += b00[3] * a01[1];\n                result[10][2] += b00[2] * a01[1];\n                result[12][2] += b00[2] * a01[2];\n                result[12][3] += b00[3] * a01[2];\n                result[8][3]  += b00[3] * a01[0];\n                result[8][2]  += b00[2] * a01[0];\n                result[6][2]  += b00[2] * a00[3];\n                result[6][3]  += b00[3] * a00[3];\n                result[2][3]  += b00[3] * a00[1];\n                result[2][2]  += b00[2] * a00[1];\n                result[4][2]  += b00[2] * a00[2];\n                result[4][3]  += b00[3] * a00[2];\n                result[0][3]  += b00[3] * a00[0];\n                result[0][2]  += b00[2] * a00[0];\n\n                result[5][0]  += b01[0] * a00[2];\n                result[5][1]  += b01[1] * a00[2];\n                result[1][1]  += b01[1] * a00[0];\n                result[1][0]  += b01[0] * a00[0];\n                result[7][0]  += b01[0] * a00[3];\n                result[7][1]  += b01[1] * a00[3];\n                result[3][1]  += b01[1] * a00[1];\n                result[3][0]  += b01[0] * a00[1];\n                result[13][0] += b01[0] * a01[2];\n                result[13][1] += b01[1] * a01[2];\n                result[9][1]  += b01[1] * a01[0];\n                result[9][0]  += b01[0] * a01[0];\n                result[15][0] += b01[0] * a01[3];\n                result[15][1] += b01[1] * a01[3];\n                result[11][1] += b01[1] * a01[1];\n                result[11][0] += b01[0] * a01[1];\n\n                result[15][2] += b01[2] * a01[3];\n                result[15][3] += b01[3] * a01[3];\n                result[11][3] += b01[3] * a01[1];\n                result[11][2] += b01[2] * a01[1];\n                result[13][2] += b01[2] * a01[2];\n                result[13][3] += b01[3] * a01[2];\n                result[9][3]  += b01[3] * a01[0];\n                result[9][2]  += b01[2] * a01[0];\n                result[7][2]  += b01[2] * a00[3];\n                result[7][3]  += b01[3] * a00[3];\n                result[3][3]  += b01[3] * a00[1];\n                result[3][2]  += b01[2] * a00[1];\n                result[5][2]  += b01[2] * a00[2];\n                result[5][3]  += b01[3] * a00[2];\n                result[1][3]  += b01[3] * a00[0];\n                result[1][2]  += b01[2] * a00[0];\n            }\n        }\n\n        shared_offset4 ^= 32 * 8;\n        read_A_offset4 ^= 32 * 8;\n        read_B_offset4 ^= 32 * 8;\n        track0 += stride_k * 8;\n        track2 += stride_k * 8;\n        track4 += stride_k * 8;\n        track6 += stride_k * 8;\n    }\n\n    {\n    \n#if OPTIMIZE && N_DIVIDABLE_BY_64\n    #if WITH_BIAS\n        float4 b[2];\n        const device float4 *bias4 = (const device float4 *)(weight_buffer + meta_buffer[3]);\n        b[0] = bias4[group_position.y * 16 + n_offset * 2 + 0];\n        b[1] = bias4[group_position.y * 16 + n_offset * 2 + 1];\n    #endif\n    \n        device float4 *C4 = (device float4 *)(data_buffer + meta_buffer[2]);\n        const int N4 = N >> 2;\n        int m = group_position.x * 64 + m_offset * 8;\n        for (int m_sub = 0; m_sub < 8; m_sub++)\n        {\n\n    #if !M_DIVIDABLE_BY_64\n            if (m >= M) continue;\n    #endif\n\n            const int n = group_position.y * 16 + n_offset * 2;\n            float4 result0 = result[m_sub * 2 + 0];\n            float4 result1 = result[m_sub * 2 + 1];\n\n    #if WITH_BIAS\n            result0 += b[0];\n            result1 += b[1];\n    #endif\n\n    #if HAS_INLINE\n            result0[0] = (result0[0]>0?result0[0]:0);\n            result0[1] = (result0[1]>0?result0[1]:0);\n            result0[2] = (result0[2]>0?result0[2]:0);\n            result0[3] = (result0[3]>0?result0[3]:0);\n            result1[0] = (result1[0]>0?result1[0]:0);\n            result1[1] = (result1[1]>0?result1[1]:0);\n            result1[2] = (result1[2]>0?result1[2]:0);\n            result1[3] = (result1[3]>0?result1[3]:0);\n    #endif\n\n            C4[m * N4 + n + 0] = result0;\n            C4[m * N4 + n + 1] = result1;\n            \n            m++;\n        }\n#else\n    #if WITH_BIAS\n        const device float *bias = weight_buffer + meta_buffer[3];\n        float b[8];\n        for (int n_sub = 0; n_sub < 8; n_sub++)\n        {\n            b[n_sub] = (group_position.y * 64 + n_offset * 8 + n_sub < N)\n                ? bias[group_position.y * 64 + n_offset * 8 + n_sub]\n                : 0;\n        }\n    #endif\n\n        device float *C = data_buffer + meta_buffer[2];\n        int m = group_position.x * 64 + m_offset * 8;\n        for (int m_sub = 0; m_sub < 8; m_sub++)\n        {\n            int n = group_position.y * 64 + n_offset * 8;\n\n            for (int n_sub1 = 0; n_sub1 < 2; n_sub1++)\n            {\n                for (int n_sub2 = 0; n_sub2 < 4; n_sub2++)\n                {\n\n    #if WITH_BIAS\n        #if OPTIMIZE && M_DIVIDABLE_BY_64\n                    (         n < N) ? (C[m * N + n] = (result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2]>0?result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2]:0)) : 0;\n        #else\n                    (m < M && n < N) ? (C[m * N + n] = (result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2]>0?result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2]:0)) : 0;\n        #endif\n    #else\n        #if OPTIMIZE && M_DIVIDABLE_BY_64\n                    (         n < N) ? (C[m * N + n] = (result[m_sub * 2 + n_sub1][n_sub2]>0?result[m_sub * 2 + n_sub1][n_sub2]:0)) : 0;\n        #else\n                    (m < M && n < N) ? (C[m * N + n] = (result[m_sub * 2 + n_sub1][n_sub2]>0?result[m_sub * 2 + n_sub1][n_sub2]:0)) : 0;\n        #endif\n    #endif\n                    n++;\n                }\n            }\n            \n            m++;\n        }\n#endif\n\n    }\n\n\n#undef M_DIVIDABLE_BY_64\n#undef N_DIVIDABLE_BY_64\n#undef K_DIVIDABLE_BY_8\n#undef TRANSPOSE_A\n#undef TRANSPOSE_B\n#undef A_STRIDE_K\n#undef B_STRIDE_K\n#undef A_STRIDE_M\n#undef A_STRIDE_M\n#undef WITH_BIAS\n#undef HAS_INLINE\n}\n\n\nkernel void sgemm_a9be2ab4b5e5fb537f0aa8f376574568f7fb0a432167d3f83543bf78(const device float *weight_buffer[[buffer(0)]],\n                          device float *data_buffer[[buffer(1)]],\n                          const device int * meta_buffer [[buffer(2)]],\n                          ushort index[[thread_index_in_threadgroup]],\n                          ushort2 group_position[[threadgroup_position_in_grid]])\n{\n#define TRANSPOSE_A 1\n#define TRANSPOSE_B 1\n#define M_DIVIDABLE_BY_64 1\n#define N_DIVIDABLE_BY_64 1\n#define K_DIVIDABLE_BY_8 1\n\n#if TRANSPOSE_A\n    #define A_STRIDE_K 1\n    #define A_STRIDE_M K\n#else\n    #define A_STRIDE_K M\n    #define A_STRIDE_M 1\n#endif\n\n#if TRANSPOSE_B\n    #define B_STRIDE_K N\n    #define B_STRIDE_N 1\n#else\n    #define B_STRIDE_K 1\n    #define B_STRIDE_N K\n#endif\n\n#define WITH_BIAS 1\n#define HAS_INLINE 1\n\n\n#if K_DIVIDABLE_BY_8 && M_DIVIDABLE_BY_64  && N_DIVIDABLE_BY_64 && !TRANSPOSE_A && TRANSPOSE_B && OPTIMIZE\n    const device float4 *load_target4 = (index & 32) \n        ? (const device float4 *)(weight_buffer + meta_buffer[1]) \n        : (const device float4 *)(data_buffer + meta_buffer[0]);\n#else\n    const device float *load_target = (index & 32) \n        ? (weight_buffer + meta_buffer[1]) \n        : (data_buffer + meta_buffer[0]);\n#endif\n\n    const int M = meta_buffer[4];\n    const int N = meta_buffer[5];\n\n    const int K = meta_buffer[6];\n\n    threadgroup float4 shared4[32 * 8 * 2];\n\n    const int stride_k = (index & 32) ? B_STRIDE_K : A_STRIDE_K;\n    const int stride_mn = (index & 32) ? B_STRIDE_N : A_STRIDE_M;\n\n    const int m_offset = index & 7;\n    const int n_offset = index >> 3;\n\n    const int mn_load_offset = ((index & 32) ? group_position.y : group_position.x) * 64 + (index & 15) * 4;\n    const int k_load_offset = ((index & 16) ? 1 : 0);\n\n    int track0 = mn_load_offset * stride_mn + (k_load_offset + 0) * stride_k;\n    int track2 = track0 + 2 * stride_k;\n    int track4 = track0 + 4 * stride_k;\n    int track6 = track0 + 6 * stride_k;\n\n#if !OPTIMIZE || !M_DIVIDABLE_BY_64 || !N_DIVIDABLE_BY_64\n    const int max_MN = (index & 32) ? N : M;\n#endif\n\n    int shared_offset4 = ((index & 32) ? 16 : 0) + k_load_offset * 32 + (index & 15);\n    int read_A_offset4 = m_offset * 2;\n    int read_B_offset4 = n_offset * 2 + 16;\n\n    float4 result[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    int k = 0;\n\n    while (k < K)\n    {\n        {\n#if OPTIMIZE && K_DIVIDABLE_BY_8\n    #if OPTIMIZE && M_DIVIDABLE_BY_64 && N_DIVIDABLE_BY_64\n        #if OPTIMIZE && !TRANSPOSE_A && TRANSPOSE_B\n            shared4[shared_offset4 + 32 * 0] = load_target4[track0 >> 2];\n            shared4[shared_offset4 + 32 * 2] = load_target4[track2 >> 2];\n            shared4[shared_offset4 + 32 * 4] = load_target4[track4 >> 2];\n            shared4[shared_offset4 + 32 * 6] = load_target4[track6 >> 2];\n        #else\n            shared4[shared_offset4 + 32 * 0] = float4(\n                load_target[track0 + stride_mn * 0],\n                load_target[track0 + stride_mn * 1],\n                load_target[track0 + stride_mn * 2],\n                load_target[track0 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 2] = float4(\n                load_target[track2 + stride_mn * 0],\n                load_target[track2 + stride_mn * 1],\n                load_target[track2 + stride_mn * 2],\n                load_target[track2 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 4] = float4(\n                load_target[track4 + stride_mn * 0],\n                load_target[track4 + stride_mn * 1],\n                load_target[track4 + stride_mn * 2],\n                load_target[track4 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 6] = float4(\n                load_target[track6 + stride_mn * 0],\n                load_target[track6 + stride_mn * 1],\n                load_target[track6 + stride_mn * 2],\n                load_target[track6 + stride_mn * 3]\n            ); \n        #endif\n    #else\n            shared4[shared_offset4 + 32 * 0] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track0 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track0 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track0 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track0 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 2] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track2 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track2 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track2 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track2 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 4] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track4 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track4 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track4 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track4 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 6] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track6 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track6 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track6 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track6 + stride_mn * 3]\n            ); \n    #endif\n\n            k += 8;\n#else\n    #if OPTIMIZE && M_DIVIDABLE_BY_64 && N_DIVIDABLE_BY_64\n            shared4[shared_offset4 + 32 * 0] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 2] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 4] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 6] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 3]\n            ); \n            k += 2;\n    #else\n            shared4[shared_offset4 + 32 * 0] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track0 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track0 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track0 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track0 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 2] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track2 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track2 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track2 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track2 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 4] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track4 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track4 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track4 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track4 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 6] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track6 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track6 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track6 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track6 + stride_mn * 3]\n            ); \n            k += 2;\n    #endif\n#endif\n        }\n\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n\n        {\n            for (int k_sub = 0; k_sub < 8; k_sub++)\n            {\n                float4 a00 = shared4[32 * k_sub + read_A_offset4 + 0];\n                float4 a01 = shared4[32 * k_sub + read_A_offset4 + 1];\n                float4 b00 = shared4[32 * k_sub + read_B_offset4 + 0];\n                float4 b01 = shared4[32 * k_sub + read_B_offset4 + 1];\n\n                result[4][0]  += b00[0] * a00[2];\n                result[4][1]  += b00[1] * a00[2];\n                result[0][1]  += b00[1] * a00[0];\n                result[0][0]  += b00[0] * a00[0];\n                result[6][0]  += b00[0] * a00[3];\n                result[6][1]  += b00[1] * a00[3];\n                result[2][1]  += b00[1] * a00[1];\n                result[2][0]  += b00[0] * a00[1];\n                result[12][0] += b00[0] * a01[2];\n                result[12][1] += b00[1] * a01[2];\n                result[8][1]  += b00[1] * a01[0];\n                result[8][0]  += b00[0] * a01[0];\n                result[14][0] += b00[0] * a01[3];\n                result[14][1] += b00[1] * a01[3];\n                result[10][1] += b00[1] * a01[1];\n                result[10][0] += b00[0] * a01[1];\n\n                result[14][2] += b00[2] * a01[3];\n                result[14][3] += b00[3] * a01[3];\n                result[10][3] += b00[3] * a01[1];\n                result[10][2] += b00[2] * a01[1];\n                result[12][2] += b00[2] * a01[2];\n                result[12][3] += b00[3] * a01[2];\n                result[8][3]  += b00[3] * a01[0];\n                result[8][2]  += b00[2] * a01[0];\n                result[6][2]  += b00[2] * a00[3];\n                result[6][3]  += b00[3] * a00[3];\n                result[2][3]  += b00[3] * a00[1];\n                result[2][2]  += b00[2] * a00[1];\n                result[4][2]  += b00[2] * a00[2];\n                result[4][3]  += b00[3] * a00[2];\n                result[0][3]  += b00[3] * a00[0];\n                result[0][2]  += b00[2] * a00[0];\n\n                result[5][0]  += b01[0] * a00[2];\n                result[5][1]  += b01[1] * a00[2];\n                result[1][1]  += b01[1] * a00[0];\n                result[1][0]  += b01[0] * a00[0];\n                result[7][0]  += b01[0] * a00[3];\n                result[7][1]  += b01[1] * a00[3];\n                result[3][1]  += b01[1] * a00[1];\n                result[3][0]  += b01[0] * a00[1];\n                result[13][0] += b01[0] * a01[2];\n                result[13][1] += b01[1] * a01[2];\n                result[9][1]  += b01[1] * a01[0];\n                result[9][0]  += b01[0] * a01[0];\n                result[15][0] += b01[0] * a01[3];\n                result[15][1] += b01[1] * a01[3];\n                result[11][1] += b01[1] * a01[1];\n                result[11][0] += b01[0] * a01[1];\n\n                result[15][2] += b01[2] * a01[3];\n                result[15][3] += b01[3] * a01[3];\n                result[11][3] += b01[3] * a01[1];\n                result[11][2] += b01[2] * a01[1];\n                result[13][2] += b01[2] * a01[2];\n                result[13][3] += b01[3] * a01[2];\n                result[9][3]  += b01[3] * a01[0];\n                result[9][2]  += b01[2] * a01[0];\n                result[7][2]  += b01[2] * a00[3];\n                result[7][3]  += b01[3] * a00[3];\n                result[3][3]  += b01[3] * a00[1];\n                result[3][2]  += b01[2] * a00[1];\n                result[5][2]  += b01[2] * a00[2];\n                result[5][3]  += b01[3] * a00[2];\n                result[1][3]  += b01[3] * a00[0];\n                result[1][2]  += b01[2] * a00[0];\n            }\n        }\n\n        shared_offset4 ^= 32 * 8;\n        read_A_offset4 ^= 32 * 8;\n        read_B_offset4 ^= 32 * 8;\n        track0 += stride_k * 8;\n        track2 += stride_k * 8;\n        track4 += stride_k * 8;\n        track6 += stride_k * 8;\n    }\n\n    {\n    \n#if OPTIMIZE && N_DIVIDABLE_BY_64\n    #if WITH_BIAS\n        float4 b[2];\n        const device float4 *bias4 = (const device float4 *)(weight_buffer + meta_buffer[3]);\n        b[0] = bias4[group_position.y * 16 + n_offset * 2 + 0];\n        b[1] = bias4[group_position.y * 16 + n_offset * 2 + 1];\n    #endif\n    \n        device float4 *C4 = (device float4 *)(data_buffer + meta_buffer[2]);\n        const int N4 = N >> 2;\n        int m = group_position.x * 64 + m_offset * 8;\n        for (int m_sub = 0; m_sub < 8; m_sub++)\n        {\n\n    #if !M_DIVIDABLE_BY_64\n            if (m >= M) continue;\n    #endif\n\n            const int n = group_position.y * 16 + n_offset * 2;\n            float4 result0 = result[m_sub * 2 + 0];\n            float4 result1 = result[m_sub * 2 + 1];\n\n    #if WITH_BIAS\n            result0 += b[0];\n            result1 += b[1];\n    #endif\n\n    #if HAS_INLINE\n            result0[0] = result0[0];\n            result0[1] = result0[1];\n            result0[2] = result0[2];\n            result0[3] = result0[3];\n            result1[0] = result1[0];\n            result1[1] = result1[1];\n            result1[2] = result1[2];\n            result1[3] = result1[3];\n    #endif\n\n            C4[m * N4 + n + 0] = result0;\n            C4[m * N4 + n + 1] = result1;\n            \n            m++;\n        }\n#else\n    #if WITH_BIAS\n        const device float *bias = weight_buffer + meta_buffer[3];\n        float b[8];\n        for (int n_sub = 0; n_sub < 8; n_sub++)\n        {\n            b[n_sub] = (group_position.y * 64 + n_offset * 8 + n_sub < N)\n                ? bias[group_position.y * 64 + n_offset * 8 + n_sub]\n                : 0;\n        }\n    #endif\n\n        device float *C = data_buffer + meta_buffer[2];\n        int m = group_position.x * 64 + m_offset * 8;\n        for (int m_sub = 0; m_sub < 8; m_sub++)\n        {\n            int n = group_position.y * 64 + n_offset * 8;\n\n            for (int n_sub1 = 0; n_sub1 < 2; n_sub1++)\n            {\n                for (int n_sub2 = 0; n_sub2 < 4; n_sub2++)\n                {\n\n    #if WITH_BIAS\n        #if OPTIMIZE && M_DIVIDABLE_BY_64\n                    (         n < N) ? (C[m * N + n] = result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2]) : 0;\n        #else\n                    (m < M && n < N) ? (C[m * N + n] = result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2]) : 0;\n        #endif\n    #else\n        #if OPTIMIZE && M_DIVIDABLE_BY_64\n                    (         n < N) ? (C[m * N + n] = result[m_sub * 2 + n_sub1][n_sub2]) : 0;\n        #else\n                    (m < M && n < N) ? (C[m * N + n] = result[m_sub * 2 + n_sub1][n_sub2]) : 0;\n        #endif\n    #endif\n                    n++;\n                }\n            }\n            \n            m++;\n        }\n#endif\n\n    }\n\n\n#undef M_DIVIDABLE_BY_64\n#undef N_DIVIDABLE_BY_64\n#undef K_DIVIDABLE_BY_8\n#undef TRANSPOSE_A\n#undef TRANSPOSE_B\n#undef A_STRIDE_K\n#undef B_STRIDE_K\n#undef A_STRIDE_M\n#undef A_STRIDE_M\n#undef WITH_BIAS\n#undef HAS_INLINE\n}\n\n\nkernel void elementwisesum_ddc83841f1d13720fab1c95ae5207cf535216a48ae9d41fa157da605(const device float *weight_buffer[[buffer(0)]],\n                          device float *data_buffer[[buffer(1)]],\n                          const device int * meta_buffer [[buffer(2)]],\n                          uint index[[thread_position_in_grid]],\n                          uint num_threads[[threads_per_grid]])\n{\n#define N_DIVIDABLE_BY_4 1\n#define HAS_INLINE 1\n\n#if N_DIVIDABLE_BY_4\n    #define T_VALUE float4\n#else\n    #define T_VALUE float\n#endif\n\n\n#if OPTIMIZE && N_DIVIDABLE_BY_4\n    const device float4 *X0 = (const device float4 *)(data_buffer + meta_buffer[0]);\n    const device float4 *X1 = (const device float4 *)(data_buffer + meta_buffer[1]);\n    device float4 *Y = (device float4 *)(data_buffer + meta_buffer[2]);\n    const int N = (meta_buffer[3]) >> 2;\n#else\n    const device float *X0 = data_buffer + meta_buffer[0];\n    const device float *X1 = data_buffer + meta_buffer[1];\n    device float *Y = data_buffer + meta_buffer[2];\n    const int N = meta_buffer[3];\n#endif\n  \n    for (int gid = index; gid < N; gid += num_threads) {\n\n        T_VALUE result = X0[gid] + X1[gid];\n\n#if OPTIMIZE && HAS_INLINE\n    #if OPTIMIZE && N_DIVIDABLE_BY_4\n            result[0] = result[0];\n            result[1] = result[1];\n            result[2] = result[2];\n            result[3] = result[3];\n    #else\n            result = result;\n    #endif\n#endif\n\n        Y[gid] = result;\n    }\n\n\n#undef N_DIVIDABLE_BY_4 \n#undef HAS_INLINE\n}\n\n\nkernel void sgemm_0d98ffd842960aa3b91ffe4db8338ca6d8dff5ae17c5b2fe737a1019(const device float *weight_buffer[[buffer(0)]],\n                          device float *data_buffer[[buffer(1)]],\n                          const device int * meta_buffer [[buffer(2)]],\n                          ushort index[[thread_index_in_threadgroup]],\n                          ushort2 group_position[[threadgroup_position_in_grid]])\n{\n#define TRANSPOSE_A 1\n#define TRANSPOSE_B 1\n#define M_DIVIDABLE_BY_64 1\n#define N_DIVIDABLE_BY_64 1\n#define K_DIVIDABLE_BY_8 1\n\n#if TRANSPOSE_A\n    #define A_STRIDE_K 1\n    #define A_STRIDE_M K\n#else\n    #define A_STRIDE_K M\n    #define A_STRIDE_M 1\n#endif\n\n#if TRANSPOSE_B\n    #define B_STRIDE_K N\n    #define B_STRIDE_N 1\n#else\n    #define B_STRIDE_K 1\n    #define B_STRIDE_N K\n#endif\n\n#define WITH_BIAS 0\n#define HAS_INLINE 1\n\n\n#if K_DIVIDABLE_BY_8 && M_DIVIDABLE_BY_64  && N_DIVIDABLE_BY_64 && !TRANSPOSE_A && TRANSPOSE_B && OPTIMIZE\n    const device float4 *load_target4 = (index & 32) \n        ? (const device float4 *)(weight_buffer + meta_buffer[1]) \n        : (const device float4 *)(data_buffer + meta_buffer[0]);\n#else\n    const device float *load_target = (index & 32) \n        ? (weight_buffer + meta_buffer[1]) \n        : (data_buffer + meta_buffer[0]);\n#endif\n\n    const int M = meta_buffer[4];\n    const int N = meta_buffer[5];\n\n    const int K = meta_buffer[6];\n\n    threadgroup float4 shared4[32 * 8 * 2];\n\n    const int stride_k = (index & 32) ? B_STRIDE_K : A_STRIDE_K;\n    const int stride_mn = (index & 32) ? B_STRIDE_N : A_STRIDE_M;\n\n    const int m_offset = index & 7;\n    const int n_offset = index >> 3;\n\n    const int mn_load_offset = ((index & 32) ? group_position.y : group_position.x) * 64 + (index & 15) * 4;\n    const int k_load_offset = ((index & 16) ? 1 : 0);\n\n    int track0 = mn_load_offset * stride_mn + (k_load_offset + 0) * stride_k;\n    int track2 = track0 + 2 * stride_k;\n    int track4 = track0 + 4 * stride_k;\n    int track6 = track0 + 6 * stride_k;\n\n#if !OPTIMIZE || !M_DIVIDABLE_BY_64 || !N_DIVIDABLE_BY_64\n    const int max_MN = (index & 32) ? N : M;\n#endif\n\n    int shared_offset4 = ((index & 32) ? 16 : 0) + k_load_offset * 32 + (index & 15);\n    int read_A_offset4 = m_offset * 2;\n    int read_B_offset4 = n_offset * 2 + 16;\n\n    float4 result[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    int k = 0;\n\n    while (k < K)\n    {\n        {\n#if OPTIMIZE && K_DIVIDABLE_BY_8\n    #if OPTIMIZE && M_DIVIDABLE_BY_64 && N_DIVIDABLE_BY_64\n        #if OPTIMIZE && !TRANSPOSE_A && TRANSPOSE_B\n            shared4[shared_offset4 + 32 * 0] = load_target4[track0 >> 2];\n            shared4[shared_offset4 + 32 * 2] = load_target4[track2 >> 2];\n            shared4[shared_offset4 + 32 * 4] = load_target4[track4 >> 2];\n            shared4[shared_offset4 + 32 * 6] = load_target4[track6 >> 2];\n        #else\n            shared4[shared_offset4 + 32 * 0] = float4(\n                load_target[track0 + stride_mn * 0],\n                load_target[track0 + stride_mn * 1],\n                load_target[track0 + stride_mn * 2],\n                load_target[track0 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 2] = float4(\n                load_target[track2 + stride_mn * 0],\n                load_target[track2 + stride_mn * 1],\n                load_target[track2 + stride_mn * 2],\n                load_target[track2 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 4] = float4(\n                load_target[track4 + stride_mn * 0],\n                load_target[track4 + stride_mn * 1],\n                load_target[track4 + stride_mn * 2],\n                load_target[track4 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 6] = float4(\n                load_target[track6 + stride_mn * 0],\n                load_target[track6 + stride_mn * 1],\n                load_target[track6 + stride_mn * 2],\n                load_target[track6 + stride_mn * 3]\n            ); \n        #endif\n    #else\n            shared4[shared_offset4 + 32 * 0] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track0 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track0 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track0 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track0 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 2] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track2 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track2 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track2 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track2 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 4] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track4 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track4 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track4 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track4 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 6] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track6 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track6 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track6 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track6 + stride_mn * 3]\n            ); \n    #endif\n\n            k += 8;\n#else\n    #if OPTIMIZE && M_DIVIDABLE_BY_64 && N_DIVIDABLE_BY_64\n            shared4[shared_offset4 + 32 * 0] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 2] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 4] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 6] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 3]\n            ); \n            k += 2;\n    #else\n            shared4[shared_offset4 + 32 * 0] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track0 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track0 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track0 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track0 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 2] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track2 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track2 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track2 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track2 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 4] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track4 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track4 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track4 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track4 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 6] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track6 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track6 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track6 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track6 + stride_mn * 3]\n            ); \n            k += 2;\n    #endif\n#endif\n        }\n\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n\n        {\n            for (int k_sub = 0; k_sub < 8; k_sub++)\n            {\n                float4 a00 = shared4[32 * k_sub + read_A_offset4 + 0];\n                float4 a01 = shared4[32 * k_sub + read_A_offset4 + 1];\n                float4 b00 = shared4[32 * k_sub + read_B_offset4 + 0];\n                float4 b01 = shared4[32 * k_sub + read_B_offset4 + 1];\n\n                result[4][0]  += b00[0] * a00[2];\n                result[4][1]  += b00[1] * a00[2];\n                result[0][1]  += b00[1] * a00[0];\n                result[0][0]  += b00[0] * a00[0];\n                result[6][0]  += b00[0] * a00[3];\n                result[6][1]  += b00[1] * a00[3];\n                result[2][1]  += b00[1] * a00[1];\n                result[2][0]  += b00[0] * a00[1];\n                result[12][0] += b00[0] * a01[2];\n                result[12][1] += b00[1] * a01[2];\n                result[8][1]  += b00[1] * a01[0];\n                result[8][0]  += b00[0] * a01[0];\n                result[14][0] += b00[0] * a01[3];\n                result[14][1] += b00[1] * a01[3];\n                result[10][1] += b00[1] * a01[1];\n                result[10][0] += b00[0] * a01[1];\n\n                result[14][2] += b00[2] * a01[3];\n                result[14][3] += b00[3] * a01[3];\n                result[10][3] += b00[3] * a01[1];\n                result[10][2] += b00[2] * a01[1];\n                result[12][2] += b00[2] * a01[2];\n                result[12][3] += b00[3] * a01[2];\n                result[8][3]  += b00[3] * a01[0];\n                result[8][2]  += b00[2] * a01[0];\n                result[6][2]  += b00[2] * a00[3];\n                result[6][3]  += b00[3] * a00[3];\n                result[2][3]  += b00[3] * a00[1];\n                result[2][2]  += b00[2] * a00[1];\n                result[4][2]  += b00[2] * a00[2];\n                result[4][3]  += b00[3] * a00[2];\n                result[0][3]  += b00[3] * a00[0];\n                result[0][2]  += b00[2] * a00[0];\n\n                result[5][0]  += b01[0] * a00[2];\n                result[5][1]  += b01[1] * a00[2];\n                result[1][1]  += b01[1] * a00[0];\n                result[1][0]  += b01[0] * a00[0];\n                result[7][0]  += b01[0] * a00[3];\n                result[7][1]  += b01[1] * a00[3];\n                result[3][1]  += b01[1] * a00[1];\n                result[3][0]  += b01[0] * a00[1];\n                result[13][0] += b01[0] * a01[2];\n                result[13][1] += b01[1] * a01[2];\n                result[9][1]  += b01[1] * a01[0];\n                result[9][0]  += b01[0] * a01[0];\n                result[15][0] += b01[0] * a01[3];\n                result[15][1] += b01[1] * a01[3];\n                result[11][1] += b01[1] * a01[1];\n                result[11][0] += b01[0] * a01[1];\n\n                result[15][2] += b01[2] * a01[3];\n                result[15][3] += b01[3] * a01[3];\n                result[11][3] += b01[3] * a01[1];\n                result[11][2] += b01[2] * a01[1];\n                result[13][2] += b01[2] * a01[2];\n                result[13][3] += b01[3] * a01[2];\n                result[9][3]  += b01[3] * a01[0];\n                result[9][2]  += b01[2] * a01[0];\n                result[7][2]  += b01[2] * a00[3];\n                result[7][3]  += b01[3] * a00[3];\n                result[3][3]  += b01[3] * a00[1];\n                result[3][2]  += b01[2] * a00[1];\n                result[5][2]  += b01[2] * a00[2];\n                result[5][3]  += b01[3] * a00[2];\n                result[1][3]  += b01[3] * a00[0];\n                result[1][2]  += b01[2] * a00[0];\n            }\n        }\n\n        shared_offset4 ^= 32 * 8;\n        read_A_offset4 ^= 32 * 8;\n        read_B_offset4 ^= 32 * 8;\n        track0 += stride_k * 8;\n        track2 += stride_k * 8;\n        track4 += stride_k * 8;\n        track6 += stride_k * 8;\n    }\n\n    {\n    \n#if OPTIMIZE && N_DIVIDABLE_BY_64\n    #if WITH_BIAS\n        float4 b[2];\n        const device float4 *bias4 = (const device float4 *)(weight_buffer + meta_buffer[3]);\n        b[0] = bias4[group_position.y * 16 + n_offset * 2 + 0];\n        b[1] = bias4[group_position.y * 16 + n_offset * 2 + 1];\n    #endif\n    \n        device float4 *C4 = (device float4 *)(data_buffer + meta_buffer[2]);\n        const int N4 = N >> 2;\n        int m = group_position.x * 64 + m_offset * 8;\n        for (int m_sub = 0; m_sub < 8; m_sub++)\n        {\n\n    #if !M_DIVIDABLE_BY_64\n            if (m >= M) continue;\n    #endif\n\n            const int n = group_position.y * 16 + n_offset * 2;\n            float4 result0 = result[m_sub * 2 + 0];\n            float4 result1 = result[m_sub * 2 + 1];\n\n    #if WITH_BIAS\n            result0 += b[0];\n            result1 += b[1];\n    #endif\n\n    #if HAS_INLINE\n            result0[0] = result0[0];\n            result0[1] = result0[1];\n            result0[2] = result0[2];\n            result0[3] = result0[3];\n            result1[0] = result1[0];\n            result1[1] = result1[1];\n            result1[2] = result1[2];\n            result1[3] = result1[3];\n    #endif\n\n            C4[m * N4 + n + 0] = result0;\n            C4[m * N4 + n + 1] = result1;\n            \n            m++;\n        }\n#else\n    #if WITH_BIAS\n        const device float *bias = weight_buffer + meta_buffer[3];\n        float b[8];\n        for (int n_sub = 0; n_sub < 8; n_sub++)\n        {\n            b[n_sub] = (group_position.y * 64 + n_offset * 8 + n_sub < N)\n                ? bias[group_position.y * 64 + n_offset * 8 + n_sub]\n                : 0;\n        }\n    #endif\n\n        device float *C = data_buffer + meta_buffer[2];\n        int m = group_position.x * 64 + m_offset * 8;\n        for (int m_sub = 0; m_sub < 8; m_sub++)\n        {\n            int n = group_position.y * 64 + n_offset * 8;\n\n            for (int n_sub1 = 0; n_sub1 < 2; n_sub1++)\n            {\n                for (int n_sub2 = 0; n_sub2 < 4; n_sub2++)\n                {\n\n    #if WITH_BIAS\n        #if OPTIMIZE && M_DIVIDABLE_BY_64\n                    (         n < N) ? (C[m * N + n] = result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2]) : 0;\n        #else\n                    (m < M && n < N) ? (C[m * N + n] = result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2]) : 0;\n        #endif\n    #else\n        #if OPTIMIZE && M_DIVIDABLE_BY_64\n                    (         n < N) ? (C[m * N + n] = result[m_sub * 2 + n_sub1][n_sub2]) : 0;\n        #else\n                    (m < M && n < N) ? (C[m * N + n] = result[m_sub * 2 + n_sub1][n_sub2]) : 0;\n        #endif\n    #endif\n                    n++;\n                }\n            }\n            \n            m++;\n        }\n#endif\n\n    }\n\n\n#undef M_DIVIDABLE_BY_64\n#undef N_DIVIDABLE_BY_64\n#undef K_DIVIDABLE_BY_8\n#undef TRANSPOSE_A\n#undef TRANSPOSE_B\n#undef A_STRIDE_K\n#undef B_STRIDE_K\n#undef A_STRIDE_M\n#undef A_STRIDE_M\n#undef WITH_BIAS\n#undef HAS_INLINE\n}\n\n\nkernel void col2im_4acb2698e5a17440fd70c40ff9ad52a79bf489ffdf7bf17453d6b928(const device float *param_buffer[[buffer(0)]],\n                          device float *data_buffer[[buffer(1)]],\n                          const device int * meta_buffer [[buffer(2)]],\n                          uint index[[thread_position_in_grid]],\n                          uint num_threads[[threads_per_grid]])\n{\n    const device float *col = data_buffer + meta_buffer[1];\n    device float *im = data_buffer + meta_buffer[0];\n\n    const int N = meta_buffer[2];\n    const int C1 = meta_buffer[5];\n    const int H1 = meta_buffer[6];\n    const int W1 = meta_buffer[7];\n    const int H2 = meta_buffer[3];\n    const int W2 = meta_buffer[4];\n    const int KH = meta_buffer[8];\n    const int KW = meta_buffer[9];\n    const int SH = meta_buffer[10];\n    const int SW = meta_buffer[11];\n    const int PH = meta_buffer[12];\n    const int PW = meta_buffer[13];\n\n    for (int gid = index; gid < N*H1*W1*C1; gid += num_threads) {\n        const int c1 = gid % C1;\n        const int w1 = gid / C1 % W1;\n        const int h1 = gid / C1 / W1 % H1;\n        const int n  = gid / C1 / W1 / H1;\n\n        float sum = 0;\n        \n        for (int kh = 0; kh < KH; kh++) {\n            const int h2 = (h1 + PH - kh) / SH;\n            if ((h1 + PH - kh) % SH != 0 || h2 < 0 || h2 >= H2) continue;\n\n            for (int kw = 0; kw < KW; kw++) {\n                const int w2 = (w1 + PW - kw) / SW;\n                if ((w1 + PW - kw) % SW != 0 || w2 < 0 || w2 >= W2) continue;\n                \n                sum += col[((((n * H2 + h2) * W2 + w2) * KH + kh) * KW + kw) * C1 + c1];\n            }\n        }\n        \n        im[gid] = sum; \n    }\n}\n\n\nkernel void elu_c5570868e1ef853205898365aac544f7d5b3e4f367a8cccdbf2beda5(const device float *param_buffer[[buffer(0)]],\n                          device float *data_buffer[[buffer(1)]],\n                          const device int * meta_buffer [[buffer(2)]],\n                          uint index[[thread_position_in_grid]],\n                          uint num_threads[[threads_per_grid]])\n{\n    const device float *X = data_buffer + meta_buffer[0];\n    device float *Y = data_buffer + meta_buffer[1];\n\n    const int N = meta_buffer[2];\n  \n    for (int gid = index; gid < N; gid += num_threads) {\n        float result = X[gid];\n        result = result < 0.0 ? (exp(result)-1) : result;      \n\n        Y[gid] = result;\n    }\n}\n\n\nkernel void sgemm_56f1c9d6ee847286248ba3248b17ad2991a0c71fea8d0f7cfc7fdb15(const device float *weight_buffer[[buffer(0)]],\n                          device float *data_buffer[[buffer(1)]],\n                          const device int * meta_buffer [[buffer(2)]],\n                          ushort index[[thread_index_in_threadgroup]],\n                          ushort2 group_position[[threadgroup_position_in_grid]])\n{\n#define TRANSPOSE_A 1\n#define TRANSPOSE_B 1\n#define M_DIVIDABLE_BY_64 1\n#define N_DIVIDABLE_BY_64 0\n#define K_DIVIDABLE_BY_8 1\n\n#if TRANSPOSE_A\n    #define A_STRIDE_K 1\n    #define A_STRIDE_M K\n#else\n    #define A_STRIDE_K M\n    #define A_STRIDE_M 1\n#endif\n\n#if TRANSPOSE_B\n    #define B_STRIDE_K N\n    #define B_STRIDE_N 1\n#else\n    #define B_STRIDE_K 1\n    #define B_STRIDE_N K\n#endif\n\n#define WITH_BIAS 0\n#define HAS_INLINE 1\n\n\n#if K_DIVIDABLE_BY_8 && M_DIVIDABLE_BY_64  && N_DIVIDABLE_BY_64 && !TRANSPOSE_A && TRANSPOSE_B && OPTIMIZE\n    const device float4 *load_target4 = (index & 32) \n        ? (const device float4 *)(weight_buffer + meta_buffer[1]) \n        : (const device float4 *)(data_buffer + meta_buffer[0]);\n#else\n    const device float *load_target = (index & 32) \n        ? (weight_buffer + meta_buffer[1]) \n        : (data_buffer + meta_buffer[0]);\n#endif\n\n    const int M = meta_buffer[4];\n    const int N = meta_buffer[5];\n\n    const int K = meta_buffer[6];\n\n    threadgroup float4 shared4[32 * 8 * 2];\n\n    const int stride_k = (index & 32) ? B_STRIDE_K : A_STRIDE_K;\n    const int stride_mn = (index & 32) ? B_STRIDE_N : A_STRIDE_M;\n\n    const int m_offset = index & 7;\n    const int n_offset = index >> 3;\n\n    const int mn_load_offset = ((index & 32) ? group_position.y : group_position.x) * 64 + (index & 15) * 4;\n    const int k_load_offset = ((index & 16) ? 1 : 0);\n\n    int track0 = mn_load_offset * stride_mn + (k_load_offset + 0) * stride_k;\n    int track2 = track0 + 2 * stride_k;\n    int track4 = track0 + 4 * stride_k;\n    int track6 = track0 + 6 * stride_k;\n\n#if !OPTIMIZE || !M_DIVIDABLE_BY_64 || !N_DIVIDABLE_BY_64\n    const int max_MN = (index & 32) ? N : M;\n#endif\n\n    int shared_offset4 = ((index & 32) ? 16 : 0) + k_load_offset * 32 + (index & 15);\n    int read_A_offset4 = m_offset * 2;\n    int read_B_offset4 = n_offset * 2 + 16;\n\n    float4 result[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    int k = 0;\n\n    while (k < K)\n    {\n        {\n#if OPTIMIZE && K_DIVIDABLE_BY_8\n    #if OPTIMIZE && M_DIVIDABLE_BY_64 && N_DIVIDABLE_BY_64\n        #if OPTIMIZE && !TRANSPOSE_A && TRANSPOSE_B\n            shared4[shared_offset4 + 32 * 0] = load_target4[track0 >> 2];\n            shared4[shared_offset4 + 32 * 2] = load_target4[track2 >> 2];\n            shared4[shared_offset4 + 32 * 4] = load_target4[track4 >> 2];\n            shared4[shared_offset4 + 32 * 6] = load_target4[track6 >> 2];\n        #else\n            shared4[shared_offset4 + 32 * 0] = float4(\n                load_target[track0 + stride_mn * 0],\n                load_target[track0 + stride_mn * 1],\n                load_target[track0 + stride_mn * 2],\n                load_target[track0 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 2] = float4(\n                load_target[track2 + stride_mn * 0],\n                load_target[track2 + stride_mn * 1],\n                load_target[track2 + stride_mn * 2],\n                load_target[track2 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 4] = float4(\n                load_target[track4 + stride_mn * 0],\n                load_target[track4 + stride_mn * 1],\n                load_target[track4 + stride_mn * 2],\n                load_target[track4 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 6] = float4(\n                load_target[track6 + stride_mn * 0],\n                load_target[track6 + stride_mn * 1],\n                load_target[track6 + stride_mn * 2],\n                load_target[track6 + stride_mn * 3]\n            ); \n        #endif\n    #else\n            shared4[shared_offset4 + 32 * 0] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track0 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track0 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track0 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track0 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 2] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track2 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track2 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track2 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track2 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 4] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track4 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track4 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track4 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track4 + stride_mn * 3]\n            ); \n            shared4[shared_offset4 + 32 * 6] = float4(\n                (mn_load_offset + 0 >= max_MN) ? 0 : load_target[track6 + stride_mn * 0],\n                (mn_load_offset + 1 >= max_MN) ? 0 : load_target[track6 + stride_mn * 1],\n                (mn_load_offset + 2 >= max_MN) ? 0 : load_target[track6 + stride_mn * 2],\n                (mn_load_offset + 3 >= max_MN) ? 0 : load_target[track6 + stride_mn * 3]\n            ); \n    #endif\n\n            k += 8;\n#else\n    #if OPTIMIZE && M_DIVIDABLE_BY_64 && N_DIVIDABLE_BY_64\n            shared4[shared_offset4 + 32 * 0] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track0 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 2] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track2 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 4] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track4 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 6] = float4(\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 0],\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 1],\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 2],\n                (k + k_load_offset >= K) ? 0 : load_target[track6 + stride_mn * 3]\n            ); \n            k += 2;\n    #else\n            shared4[shared_offset4 + 32 * 0] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track0 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track0 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track0 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track0 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 2] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track2 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track2 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track2 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track2 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 4] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track4 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track4 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track4 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track4 + stride_mn * 3]\n            ); \n            k += 2;\n\n            shared4[shared_offset4 + 32 * 6] = float4(\n                (k + k_load_offset >= K || mn_load_offset + 0 >= max_MN) ? 0 : load_target[track6 + stride_mn * 0],\n                (k + k_load_offset >= K || mn_load_offset + 1 >= max_MN) ? 0 : load_target[track6 + stride_mn * 1],\n                (k + k_load_offset >= K || mn_load_offset + 2 >= max_MN) ? 0 : load_target[track6 + stride_mn * 2],\n                (k + k_load_offset >= K || mn_load_offset + 3 >= max_MN) ? 0 : load_target[track6 + stride_mn * 3]\n            ); \n            k += 2;\n    #endif\n#endif\n        }\n\n        threadgroup_barrier(mem_flags::mem_threadgroup);\n\n        {\n            for (int k_sub = 0; k_sub < 8; k_sub++)\n            {\n                float4 a00 = shared4[32 * k_sub + read_A_offset4 + 0];\n                float4 a01 = shared4[32 * k_sub + read_A_offset4 + 1];\n                float4 b00 = shared4[32 * k_sub + read_B_offset4 + 0];\n                float4 b01 = shared4[32 * k_sub + read_B_offset4 + 1];\n\n                result[4][0]  += b00[0] * a00[2];\n                result[4][1]  += b00[1] * a00[2];\n                result[0][1]  += b00[1] * a00[0];\n                result[0][0]  += b00[0] * a00[0];\n                result[6][0]  += b00[0] * a00[3];\n                result[6][1]  += b00[1] * a00[3];\n                result[2][1]  += b00[1] * a00[1];\n                result[2][0]  += b00[0] * a00[1];\n                result[12][0] += b00[0] * a01[2];\n                result[12][1] += b00[1] * a01[2];\n                result[8][1]  += b00[1] * a01[0];\n                result[8][0]  += b00[0] * a01[0];\n                result[14][0] += b00[0] * a01[3];\n                result[14][1] += b00[1] * a01[3];\n                result[10][1] += b00[1] * a01[1];\n                result[10][0] += b00[0] * a01[1];\n\n                result[14][2] += b00[2] * a01[3];\n                result[14][3] += b00[3] * a01[3];\n                result[10][3] += b00[3] * a01[1];\n                result[10][2] += b00[2] * a01[1];\n                result[12][2] += b00[2] * a01[2];\n                result[12][3] += b00[3] * a01[2];\n                result[8][3]  += b00[3] * a01[0];\n                result[8][2]  += b00[2] * a01[0];\n                result[6][2]  += b00[2] * a00[3];\n                result[6][3]  += b00[3] * a00[3];\n                result[2][3]  += b00[3] * a00[1];\n                result[2][2]  += b00[2] * a00[1];\n                result[4][2]  += b00[2] * a00[2];\n                result[4][3]  += b00[3] * a00[2];\n                result[0][3]  += b00[3] * a00[0];\n                result[0][2]  += b00[2] * a00[0];\n\n                result[5][0]  += b01[0] * a00[2];\n                result[5][1]  += b01[1] * a00[2];\n                result[1][1]  += b01[1] * a00[0];\n                result[1][0]  += b01[0] * a00[0];\n                result[7][0]  += b01[0] * a00[3];\n                result[7][1]  += b01[1] * a00[3];\n                result[3][1]  += b01[1] * a00[1];\n                result[3][0]  += b01[0] * a00[1];\n                result[13][0] += b01[0] * a01[2];\n                result[13][1] += b01[1] * a01[2];\n                result[9][1]  += b01[1] * a01[0];\n                result[9][0]  += b01[0] * a01[0];\n                result[15][0] += b01[0] * a01[3];\n                result[15][1] += b01[1] * a01[3];\n                result[11][1] += b01[1] * a01[1];\n                result[11][0] += b01[0] * a01[1];\n\n                result[15][2] += b01[2] * a01[3];\n                result[15][3] += b01[3] * a01[3];\n                result[11][3] += b01[3] * a01[1];\n                result[11][2] += b01[2] * a01[1];\n                result[13][2] += b01[2] * a01[2];\n                result[13][3] += b01[3] * a01[2];\n                result[9][3]  += b01[3] * a01[0];\n                result[9][2]  += b01[2] * a01[0];\n                result[7][2]  += b01[2] * a00[3];\n                result[7][3]  += b01[3] * a00[3];\n                result[3][3]  += b01[3] * a00[1];\n                result[3][2]  += b01[2] * a00[1];\n                result[5][2]  += b01[2] * a00[2];\n                result[5][3]  += b01[3] * a00[2];\n                result[1][3]  += b01[3] * a00[0];\n                result[1][2]  += b01[2] * a00[0];\n            }\n        }\n\n        shared_offset4 ^= 32 * 8;\n        read_A_offset4 ^= 32 * 8;\n        read_B_offset4 ^= 32 * 8;\n        track0 += stride_k * 8;\n        track2 += stride_k * 8;\n        track4 += stride_k * 8;\n        track6 += stride_k * 8;\n    }\n\n    {\n    \n#if OPTIMIZE && N_DIVIDABLE_BY_64\n    #if WITH_BIAS\n        float4 b[2];\n        const device float4 *bias4 = (const device float4 *)(weight_buffer + meta_buffer[3]);\n        b[0] = bias4[group_position.y * 16 + n_offset * 2 + 0];\n        b[1] = bias4[group_position.y * 16 + n_offset * 2 + 1];\n    #endif\n    \n        device float4 *C4 = (device float4 *)(data_buffer + meta_buffer[2]);\n        const int N4 = N >> 2;\n        int m = group_position.x * 64 + m_offset * 8;\n        for (int m_sub = 0; m_sub < 8; m_sub++)\n        {\n\n    #if !M_DIVIDABLE_BY_64\n            if (m >= M) continue;\n    #endif\n\n            const int n = group_position.y * 16 + n_offset * 2;\n            float4 result0 = result[m_sub * 2 + 0];\n            float4 result1 = result[m_sub * 2 + 1];\n\n    #if WITH_BIAS\n            result0 += b[0];\n            result1 += b[1];\n    #endif\n\n    #if HAS_INLINE\n            result0[0] = result0[0];\n            result0[1] = result0[1];\n            result0[2] = result0[2];\n            result0[3] = result0[3];\n            result1[0] = result1[0];\n            result1[1] = result1[1];\n            result1[2] = result1[2];\n            result1[3] = result1[3];\n    #endif\n\n            C4[m * N4 + n + 0] = result0;\n            C4[m * N4 + n + 1] = result1;\n            \n            m++;\n        }\n#else\n    #if WITH_BIAS\n        const device float *bias = weight_buffer + meta_buffer[3];\n        float b[8];\n        for (int n_sub = 0; n_sub < 8; n_sub++)\n        {\n            b[n_sub] = (group_position.y * 64 + n_offset * 8 + n_sub < N)\n                ? bias[group_position.y * 64 + n_offset * 8 + n_sub]\n                : 0;\n        }\n    #endif\n\n        device float *C = data_buffer + meta_buffer[2];\n        int m = group_position.x * 64 + m_offset * 8;\n        for (int m_sub = 0; m_sub < 8; m_sub++)\n        {\n            int n = group_position.y * 64 + n_offset * 8;\n\n            for (int n_sub1 = 0; n_sub1 < 2; n_sub1++)\n            {\n                for (int n_sub2 = 0; n_sub2 < 4; n_sub2++)\n                {\n\n    #if WITH_BIAS\n        #if OPTIMIZE && M_DIVIDABLE_BY_64\n                    (         n < N) ? (C[m * N + n] = result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2]) : 0;\n        #else\n                    (m < M && n < N) ? (C[m * N + n] = result[m_sub * 2 + n_sub1][n_sub2] + b[n_sub1*4+n_sub2]) : 0;\n        #endif\n    #else\n        #if OPTIMIZE && M_DIVIDABLE_BY_64\n                    (         n < N) ? (C[m * N + n] = result[m_sub * 2 + n_sub1][n_sub2]) : 0;\n        #else\n                    (m < M && n < N) ? (C[m * N + n] = result[m_sub * 2 + n_sub1][n_sub2]) : 0;\n        #endif\n    #endif\n                    n++;\n                }\n            }\n            \n            m++;\n        }\n#endif\n\n    }\n\n\n#undef M_DIVIDABLE_BY_64\n#undef N_DIVIDABLE_BY_64\n#undef K_DIVIDABLE_BY_8\n#undef TRANSPOSE_A\n#undef TRANSPOSE_B\n#undef A_STRIDE_K\n#undef B_STRIDE_K\n#undef A_STRIDE_M\n#undef A_STRIDE_M\n#undef WITH_BIAS\n#undef HAS_INLINE\n}\n\n\nkernel void tanh_4d093f262c150685bb3ba8649b1aedd8a91b1d4e42056449061f72a2(const device float *param_buffer[[buffer(0)]],\n                          device float *data_buffer[[buffer(1)]],\n                          const device int * meta_buffer [[buffer(2)]],\n                          uint index[[thread_position_in_grid]],\n                          uint num_threads[[threads_per_grid]])\n{\n    const device float *X = data_buffer + meta_buffer[0];\n    device float *Y = data_buffer + meta_buffer[1];\n\n    const int N = meta_buffer[2];\n  \n    for (int gid = index; gid < N; gid += num_threads) {\n        Y[gid] = tanh(X[gid]);\n    }\n}\n\n\nkernel void scalaraffine_3daf34a046eb693a4a93f810672675819980cfa4239b993889317ec5(const device float *param_buffer[[buffer(0)]],\n                          device float *data_buffer[[buffer(1)]],\n                          const device int * meta_buffer [[buffer(2)]],\n                          uint index[[thread_position_in_grid]],\n                          uint num_threads[[threads_per_grid]])\n{\n    const device float *X = data_buffer + meta_buffer[0];\n    device float *Y = data_buffer + meta_buffer[1];\n\n    const float scale = *((const device float *)(& meta_buffer[3]));\n    const float bias = *((const device float *)(& meta_buffer[4]));\n    const int N = meta_buffer[2];\n\n    for (int gid = index; gid < N; gid += num_threads) {\n        float result = X[gid];\n        result = result * scale + bias;\n        Y[gid] = result;\n    }\n}\n",
  "exec_infos": [
    {
      "entry_func_name": "im2col_c11bc86fe77290c624886ebd52e1e88ff9cb3655ad3bfada8b15ad55",
      "threadgroups_per_grid": {
        "width": 30400,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        0,
        0,
        0,
        0,
        196,
        14,
        0,
        1,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        144,
        0,
        0,
        0,
        192,
        0,
        0,
        0,
        144,
        0,
        0,
        0,
        192,
        0,
        0,
        0,
        9,
        0,
        0,
        0,
        9,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        4,
        0,
        0,
        0,
        4,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "sgemm_1fe1c908701210c37c7cdbeb4c16e81d8255a13579dd647fe858078f",
      "threadgroups_per_grid": {
        "width": 432,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        196,
        14,
        0,
        192,
        2,
        13,
        0,
        0,
        68,
        1,
        0,
        32,
        228,
        15,
        0,
        0,
        108,
        0,
        0,
        32,
        0,
        0,
        0,
        243,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "axiswisescale_eb0047e7bd89ea7055f72ebafeb790e891bb2505194856bd8fe5e84d",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        68,
        1,
        0,
        192,
        162,
        13,
        0,
        0,
        128,
        13,
        0,
        32,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "axiswisebias_6be2df9cf1526331046f94fd7a124df8004489b3081b9db2c7e0fa03",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        68,
        1,
        0,
        32,
        33,
        13,
        0,
        0,
        108,
        0,
        0,
        32,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "im2col_094f568353bf9de7c01e0b777df297bf4afc40425d719b9b676a1d9f",
      "threadgroups_per_grid": {
        "width": 28324,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        196,
        14,
        0,
        1,
        0,
        0,
        0,
        32,
        0,
        0,
        0,
        144,
        0,
        0,
        0,
        192,
        0,
        0,
        0,
        72,
        0,
        0,
        0,
        96,
        0,
        0,
        0,
        4,
        0,
        0,
        0,
        4,
        0,
        0,
        0,
        2,
        0,
        0,
        0,
        2,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "sgemm_7bb39dea9313ec8d8e4c2c50047d68337ba2b05833316191856f2f17",
      "threadgroups_per_grid": {
        "width": 108,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        196,
        14,
        0,
        96,
        34,
        13,
        0,
        0,
        68,
        1,
        0,
        128,
        162,
        13,
        0,
        0,
        27,
        0,
        0,
        64,
        0,
        0,
        0,
        0,
        2,
        0,
        0
      ]
    },
    {
      "entry_func_name": "axiswisescale_eb0047e7bd89ea7055f72ebafeb790e891bb2505194856bd8fe5e84d",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        68,
        1,
        0,
        224,
        164,
        18,
        0,
        0,
        192,
        6,
        0,
        64,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "axiswisebias_6be2df9cf1526331046f94fd7a124df8004489b3081b9db2c7e0fa03",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        68,
        1,
        0,
        224,
        162,
        13,
        0,
        0,
        27,
        0,
        0,
        64,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "im2col_094f568353bf9de7c01e0b777df297bf4afc40425d719b9b676a1d9f",
      "threadgroups_per_grid": {
        "width": 7252,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        4,
        8,
        0,
        1,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        72,
        0,
        0,
        0,
        96,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        4,
        0,
        0,
        0,
        4,
        0,
        0,
        0,
        2,
        0,
        0,
        0,
        2,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "sgemm_7bb39dea9313ec8d8e4c2c50047d68337ba2b05833316191856f2f17",
      "threadgroups_per_grid": {
        "width": 27,
        "height": 2,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        4,
        8,
        0,
        0,
        0,
        0,
        0,
        0,
        68,
        1,
        0,
        163,
        165,
        27,
        0,
        192,
        6,
        0,
        0,
        128,
        0,
        0,
        0,
        0,
        4,
        0,
        0
      ]
    },
    {
      "entry_func_name": "axiswisescale_eb0047e7bd89ea7055f72ebafeb790e891bb2505194856bd8fe5e84d",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        68,
        1,
        0,
        128,
        0,
        4,
        0,
        0,
        96,
        3,
        0,
        128,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "axiswisebias_6be2df9cf1526331046f94fd7a124df8004489b3081b9db2c7e0fa03",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        68,
        1,
        0,
        99,
        166,
        27,
        0,
        192,
        6,
        0,
        0,
        128,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "im2col_884fd9f360ddda90bf2cf46891d08c8646216406a876e59098baf6e0",
      "threadgroups_per_grid": {
        "width": 1900,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        164,
        4,
        0,
        1,
        0,
        0,
        0,
        128,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "sgemm_d2120e4054f06f47109f63cd135af4cf5af06fd36eb3fc1661c88712",
      "threadgroups_per_grid": {
        "width": 27,
        "height": 2,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        164,
        4,
        0,
        32,
        163,
        13,
        0,
        0,
        4,
        35,
        0,
        96,
        164,
        18,
        0,
        192,
        6,
        0,
        0,
        128,
        0,
        0,
        0,
        128,
        4,
        0,
        0
      ]
    },
    {
      "entry_func_name": "im2col_884fd9f360ddda90bf2cf46891d08c8646216406a876e59098baf6e0",
      "threadgroups_per_grid": {
        "width": 1900,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        4,
        35,
        0,
        0,
        164,
        4,
        0,
        1,
        0,
        0,
        0,
        128,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "sgemm_a9be2ab4b5e5fb537f0aa8f376574568f7fb0a432167d3f83543bf78",
      "threadgroups_per_grid": {
        "width": 27,
        "height": 2,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        164,
        4,
        0,
        32,
        37,
        23,
        0,
        0,
        100,
        38,
        0,
        32,
        227,
        15,
        0,
        192,
        6,
        0,
        0,
        128,
        0,
        0,
        0,
        128,
        4,
        0,
        0
      ]
    },
    {
      "entry_func_name": "elementwisesum_ddc83841f1d13720fab1c95ae5207cf535216a48ae9d41fa157da605",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        100,
        38,
        0,
        0,
        68,
        1,
        0,
        0,
        100,
        38,
        0,
        0,
        96,
        3,
        0
      ]
    },
    {
      "entry_func_name": "im2col_884fd9f360ddda90bf2cf46891d08c8646216406a876e59098baf6e0",
      "threadgroups_per_grid": {
        "width": 1900,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        100,
        38,
        0,
        0,
        68,
        1,
        0,
        1,
        0,
        0,
        0,
        128,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "sgemm_d2120e4054f06f47109f63cd135af4cf5af06fd36eb3fc1661c88712",
      "threadgroups_per_grid": {
        "width": 27,
        "height": 2,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        64,
        194,
        10,
        0,
        0,
        4,
        35,
        0,
        0,
        0,
        4,
        0,
        192,
        6,
        0,
        0,
        128,
        0,
        0,
        0,
        128,
        4,
        0,
        0
      ]
    },
    {
      "entry_func_name": "im2col_884fd9f360ddda90bf2cf46891d08c8646216406a876e59098baf6e0",
      "threadgroups_per_grid": {
        "width": 1900,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        4,
        35,
        0,
        0,
        164,
        4,
        0,
        1,
        0,
        0,
        0,
        128,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "sgemm_a9be2ab4b5e5fb537f0aa8f376574568f7fb0a432167d3f83543bf78",
      "threadgroups_per_grid": {
        "width": 27,
        "height": 2,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        164,
        4,
        0,
        32,
        101,
        25,
        0,
        0,
        68,
        1,
        0,
        160,
        227,
        15,
        0,
        192,
        6,
        0,
        0,
        128,
        0,
        0,
        0,
        128,
        4,
        0,
        0
      ]
    },
    {
      "entry_func_name": "elementwisesum_ddc83841f1d13720fab1c95ae5207cf535216a48ae9d41fa157da605",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        100,
        38,
        0,
        0,
        68,
        1,
        0,
        0,
        96,
        3,
        0
      ]
    },
    {
      "entry_func_name": "im2col_884fd9f360ddda90bf2cf46891d08c8646216406a876e59098baf6e0",
      "threadgroups_per_grid": {
        "width": 1900,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        164,
        4,
        0,
        1,
        0,
        0,
        0,
        128,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "sgemm_d2120e4054f06f47109f63cd135af4cf5af06fd36eb3fc1661c88712",
      "threadgroups_per_grid": {
        "width": 27,
        "height": 2,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        164,
        4,
        0,
        64,
        130,
        8,
        0,
        0,
        4,
        35,
        0,
        64,
        1,
        4,
        0,
        192,
        6,
        0,
        0,
        128,
        0,
        0,
        0,
        128,
        4,
        0,
        0
      ]
    },
    {
      "entry_func_name": "im2col_884fd9f360ddda90bf2cf46891d08c8646216406a876e59098baf6e0",
      "threadgroups_per_grid": {
        "width": 1900,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        4,
        35,
        0,
        0,
        164,
        4,
        0,
        1,
        0,
        0,
        0,
        128,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "sgemm_a9be2ab4b5e5fb537f0aa8f376574568f7fb0a432167d3f83543bf78",
      "threadgroups_per_grid": {
        "width": 27,
        "height": 2,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        164,
        4,
        0,
        32,
        229,
        20,
        0,
        0,
        100,
        38,
        0,
        64,
        33,
        13,
        0,
        192,
        6,
        0,
        0,
        128,
        0,
        0,
        0,
        128,
        4,
        0,
        0
      ]
    },
    {
      "entry_func_name": "elementwisesum_ddc83841f1d13720fab1c95ae5207cf535216a48ae9d41fa157da605",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        100,
        38,
        0,
        0,
        68,
        1,
        0,
        0,
        100,
        38,
        0,
        0,
        96,
        3,
        0
      ]
    },
    {
      "entry_func_name": "im2col_884fd9f360ddda90bf2cf46891d08c8646216406a876e59098baf6e0",
      "threadgroups_per_grid": {
        "width": 1900,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        100,
        38,
        0,
        0,
        68,
        1,
        0,
        1,
        0,
        0,
        0,
        128,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "sgemm_d2120e4054f06f47109f63cd135af4cf5af06fd36eb3fc1661c88712",
      "threadgroups_per_grid": {
        "width": 27,
        "height": 2,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        64,
        66,
        6,
        0,
        0,
        4,
        35,
        0,
        224,
        33,
        13,
        0,
        192,
        6,
        0,
        0,
        128,
        0,
        0,
        0,
        128,
        4,
        0,
        0
      ]
    },
    {
      "entry_func_name": "im2col_884fd9f360ddda90bf2cf46891d08c8646216406a876e59098baf6e0",
      "threadgroups_per_grid": {
        "width": 1900,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        4,
        35,
        0,
        0,
        164,
        4,
        0,
        1,
        0,
        0,
        0,
        128,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "sgemm_a9be2ab4b5e5fb537f0aa8f376574568f7fb0a432167d3f83543bf78",
      "threadgroups_per_grid": {
        "width": 27,
        "height": 2,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        164,
        4,
        0,
        32,
        165,
        18,
        0,
        0,
        68,
        1,
        0,
        32,
        165,
        27,
        0,
        192,
        6,
        0,
        0,
        128,
        0,
        0,
        0,
        128,
        4,
        0,
        0
      ]
    },
    {
      "entry_func_name": "elementwisesum_ddc83841f1d13720fab1c95ae5207cf535216a48ae9d41fa157da605",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        100,
        38,
        0,
        0,
        68,
        1,
        0,
        0,
        96,
        3,
        0
      ]
    },
    {
      "entry_func_name": "im2col_884fd9f360ddda90bf2cf46891d08c8646216406a876e59098baf6e0",
      "threadgroups_per_grid": {
        "width": 1900,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        164,
        4,
        0,
        1,
        0,
        0,
        0,
        128,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "sgemm_d2120e4054f06f47109f63cd135af4cf5af06fd36eb3fc1661c88712",
      "threadgroups_per_grid": {
        "width": 27,
        "height": 2,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        164,
        4,
        0,
        192,
        1,
        4,
        0,
        0,
        100,
        38,
        0,
        64,
        2,
        13,
        0,
        192,
        6,
        0,
        0,
        128,
        0,
        0,
        0,
        128,
        4,
        0,
        0
      ]
    },
    {
      "entry_func_name": "im2col_884fd9f360ddda90bf2cf46891d08c8646216406a876e59098baf6e0",
      "threadgroups_per_grid": {
        "width": 1900,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        100,
        38,
        0,
        0,
        4,
        8,
        0,
        1,
        0,
        0,
        0,
        128,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "sgemm_a9be2ab4b5e5fb537f0aa8f376574568f7fb0a432167d3f83543bf78",
      "threadgroups_per_grid": {
        "width": 27,
        "height": 2,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        4,
        8,
        0,
        64,
        100,
        16,
        0,
        0,
        164,
        4,
        0,
        192,
        65,
        6,
        0,
        192,
        6,
        0,
        0,
        128,
        0,
        0,
        0,
        128,
        4,
        0,
        0
      ]
    },
    {
      "entry_func_name": "elementwisesum_ddc83841f1d13720fab1c95ae5207cf535216a48ae9d41fa157da605",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        164,
        4,
        0,
        0,
        68,
        1,
        0,
        0,
        164,
        4,
        0,
        0,
        96,
        3,
        0
      ]
    },
    {
      "entry_func_name": "sgemm_0d98ffd842960aa3b91ffe4db8338ca6d8dff5ae17c5b2fe737a1019",
      "threadgroups_per_grid": {
        "width": 27,
        "height": 16,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        164,
        4,
        0,
        0,
        0,
        2,
        0,
        0,
        4,
        8,
        0,
        0,
        0,
        0,
        0,
        192,
        6,
        0,
        0,
        0,
        4,
        0,
        0,
        128,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "col2im_4acb2698e5a17440fd70c40ff9ad52a79bf489ffdf7bf17453d6b928",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        4,
        8,
        0,
        1,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        72,
        0,
        0,
        0,
        96,
        0,
        0,
        0,
        4,
        0,
        0,
        0,
        4,
        0,
        0,
        0,
        2,
        0,
        0,
        0,
        2,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "axiswisebias_6be2df9cf1526331046f94fd7a124df8004489b3081b9db2c7e0fa03",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        68,
        1,
        0,
        35,
        166,
        27,
        0,
        0,
        27,
        0,
        0,
        64,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "elu_c5570868e1ef853205898365aac544f7d5b3e4f367a8cccdbf2beda5",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        68,
        1,
        0,
        0,
        192,
        6,
        0
      ]
    },
    {
      "entry_func_name": "axiswisescale_eb0047e7bd89ea7055f72ebafeb790e891bb2505194856bd8fe5e84d",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        68,
        1,
        0,
        0,
        1,
        4,
        0,
        0,
        192,
        6,
        0,
        64,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "axiswisebias_6be2df9cf1526331046f94fd7a124df8004489b3081b9db2c7e0fa03",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        68,
        1,
        0,
        227,
        166,
        27,
        0,
        0,
        27,
        0,
        0,
        64,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "sgemm_0d98ffd842960aa3b91ffe4db8338ca6d8dff5ae17c5b2fe737a1019",
      "threadgroups_per_grid": {
        "width": 108,
        "height": 8,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        64,
        228,
        15,
        0,
        0,
        196,
        14,
        0,
        0,
        0,
        0,
        0,
        0,
        27,
        0,
        0,
        0,
        2,
        0,
        0,
        64,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "col2im_4acb2698e5a17440fd70c40ff9ad52a79bf489ffdf7bf17453d6b928",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        196,
        14,
        0,
        1,
        0,
        0,
        0,
        72,
        0,
        0,
        0,
        96,
        0,
        0,
        0,
        32,
        0,
        0,
        0,
        144,
        0,
        0,
        0,
        192,
        0,
        0,
        0,
        4,
        0,
        0,
        0,
        4,
        0,
        0,
        0,
        2,
        0,
        0,
        0,
        2,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "axiswisebias_6be2df9cf1526331046f94fd7a124df8004489b3081b9db2c7e0fa03",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        68,
        1,
        0,
        192,
        33,
        13,
        0,
        0,
        108,
        0,
        0,
        32,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "elu_c5570868e1ef853205898365aac544f7d5b3e4f367a8cccdbf2beda5",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        68,
        1,
        0,
        0,
        128,
        13,
        0
      ]
    },
    {
      "entry_func_name": "axiswisescale_eb0047e7bd89ea7055f72ebafeb790e891bb2505194856bd8fe5e84d",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        68,
        1,
        0,
        64,
        164,
        18,
        0,
        0,
        128,
        13,
        0,
        32,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "axiswisebias_6be2df9cf1526331046f94fd7a124df8004489b3081b9db2c7e0fa03",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        68,
        1,
        0,
        96,
        162,
        13,
        0,
        0,
        108,
        0,
        0,
        32,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "sgemm_56f1c9d6ee847286248ba3248b17ad2991a0c71fea8d0f7cfc7fdb15",
      "threadgroups_per_grid": {
        "width": 432,
        "height": 4,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 64,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        35,
        167,
        27,
        0,
        0,
        196,
        14,
        0,
        0,
        0,
        0,
        0,
        0,
        108,
        0,
        0,
        243,
        0,
        0,
        0,
        32,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "col2im_4acb2698e5a17440fd70c40ff9ad52a79bf489ffdf7bf17453d6b928",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        196,
        14,
        0,
        1,
        0,
        0,
        0,
        144,
        0,
        0,
        0,
        192,
        0,
        0,
        0,
        3,
        0,
        0,
        0,
        144,
        0,
        0,
        0,
        192,
        0,
        0,
        0,
        9,
        0,
        0,
        0,
        9,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        4,
        0,
        0,
        0,
        4,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "axiswisebias_6be2df9cf1526331046f94fd7a124df8004489b3081b9db2c7e0fa03",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        68,
        1,
        0,
        160,
        165,
        27,
        0,
        0,
        108,
        0,
        0,
        3,
        0,
        0,
        0
      ]
    },
    {
      "entry_func_name": "tanh_4d093f262c150685bb3ba8649b1aedd8a91b1d4e42056449061f72a2",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        68,
        1,
        0,
        0,
        68,
        1,
        0
      ]
    },
    {
      "entry_func_name": "scalaraffine_3daf34a046eb693a4a93f810672675819980cfa4239b993889317ec5",
      "threadgroups_per_grid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threads_per_thread_group": {
        "width": 1024,
        "height": 1,
        "depth": 1
      },
      "meta_buffer": [
        0,
        68,
        1,
        0,
        0,
        68,
        1,
        0,
        0,
        68,
        1,
        0,
        0,
        0,
        255,
        66,
        0,
        0,
        255,
        66
      ]
    }
  ],
  "weight_allocation": {
    "total_size": 1820035,
    "allocation": {
      "ConstantVariable82": {
        "name": "ConstantVariable82",
        "offset": 0,
        "size": 131072
      },
      "ConstantVariable6": {
        "name": "ConstantVariable6",
        "offset": 131072,
        "size": 131072
      },
      "ConstantVariable124": {
        "name": "ConstantVariable124",
        "offset": 262144,
        "size": 128
      },
      "ConstantVariable96": {
        "name": "ConstantVariable96",
        "offset": 262272,
        "size": 128
      },
      "ConstantVariable118": {
        "name": "ConstantVariable118",
        "offset": 262400,
        "size": 64
      },
      "ConstantVariable126": {
        "name": "ConstantVariable126",
        "offset": 262464,
        "size": 128
      },
      "ConstantVariable57": {
        "name": "ConstantVariable57",
        "offset": 262592,
        "size": 147456
      },
      "ConstantVariable131": {
        "name": "ConstantVariable131",
        "offset": 410048,
        "size": 128
      },
      "ConstantVariable49": {
        "name": "ConstantVariable49",
        "offset": 410176,
        "size": 147456
      },
      "ConstantVariable41": {
        "name": "ConstantVariable41",
        "offset": 557632,
        "size": 147456
      },
      "ConstantVariable33": {
        "name": "ConstantVariable33",
        "offset": 705088,
        "size": 147456
      },
      "ConstantVariable130": {
        "name": "ConstantVariable130",
        "offset": 852544,
        "size": 128
      },
      "ConstantVariable79": {
        "name": "ConstantVariable79",
        "offset": 852672,
        "size": 7776
      },
      "ConstantVariable93": {
        "name": "ConstantVariable93",
        "offset": 860448,
        "size": 32
      },
      "ConstantVariable127": {
        "name": "ConstantVariable127",
        "offset": 860480,
        "size": 128
      },
      "ConstantVariable76": {
        "name": "ConstantVariable76",
        "offset": 860608,
        "size": 32
      },
      "ConstantVariable128": {
        "name": "ConstantVariable128",
        "offset": 860640,
        "size": 128
      },
      "ConstantVariable80": {
        "name": "ConstantVariable80",
        "offset": 860768,
        "size": 32768
      },
      "ConstantVariable121": {
        "name": "ConstantVariable121",
        "offset": 893536,
        "size": 32
      },
      "ConstantVariable81": {
        "name": "ConstantVariable81",
        "offset": 893568,
        "size": 64
      },
      "ConstantVariable92": {
        "name": "ConstantVariable92",
        "offset": 893632,
        "size": 32
      },
      "ConstantVariable95": {
        "name": "ConstantVariable95",
        "offset": 893664,
        "size": 64
      },
      "ConstantVariable84": {
        "name": "ConstantVariable84",
        "offset": 893728,
        "size": 147456
      },
      "ConstantVariable123": {
        "name": "ConstantVariable123",
        "offset": 1041184,
        "size": 128
      },
      "ConstantVariable125": {
        "name": "ConstantVariable125",
        "offset": 1041312,
        "size": 128
      },
      "ConstantVariable78": {
        "name": "ConstantVariable78",
        "offset": 1041440,
        "size": 32
      },
      "ConstantVariable9": {
        "name": "ConstantVariable9",
        "offset": 1041472,
        "size": 32768
      },
      "ConstantVariable59": {
        "name": "ConstantVariable59",
        "offset": 1074240,
        "size": 147456
      },
      "ConstantVariable120": {
        "name": "ConstantVariable120",
        "offset": 1221696,
        "size": 32
      },
      "ConstantVariable122": {
        "name": "ConstantVariable122",
        "offset": 1221728,
        "size": 128
      },
      "ConstantVariable94": {
        "name": "ConstantVariable94",
        "offset": 1221856,
        "size": 64
      },
      "ConstantVariable51": {
        "name": "ConstantVariable51",
        "offset": 1221920,
        "size": 147456
      },
      "ConstantVariable43": {
        "name": "ConstantVariable43",
        "offset": 1369376,
        "size": 147456
      },
      "ConstantVariable86": {
        "name": "ConstantVariable86",
        "offset": 1516832,
        "size": 147456
      },
      "ConstantVariable35": {
        "name": "ConstantVariable35",
        "offset": 1664288,
        "size": 147456
      },
      "ConstantVariable129": {
        "name": "ConstantVariable129",
        "offset": 1811744,
        "size": 128
      },
      "ConstantVariable75": {
        "name": "ConstantVariable75",
        "offset": 1811872,
        "size": 3
      },
      "ConstantVariable83": {
        "name": "ConstantVariable83",
        "offset": 1811875,
        "size": 128
      },
      "ConstantVariable77": {
        "name": "ConstantVariable77",
        "offset": 1812003,
        "size": 64
      },
      "ConstantVariable97": {
        "name": "ConstantVariable97",
        "offset": 1812067,
        "size": 128
      },
      "ConstantVariable119": {
        "name": "ConstantVariable119",
        "offset": 1812195,
        "size": 64
      },
      "ConstantVariable12": {
        "name": "ConstantVariable12",
        "offset": 1812259,
        "size": 7776
      }
    }
  },
  "weight_encoding": "eightbit",
  "variable_allocation": {
    "total_size": 7686144,
    "allocation": {
      "Variable73": {
        "name": "Variable73",
        "offset": 82944,
        "size": 884736
      },
      "Variable77": {
        "name": "Variable77",
        "offset": 82944,
        "size": 82944
      },
      "Variable95": {
        "name": "Variable95",
        "offset": 304128,
        "size": 1990656
      },
      "Variable8": {
        "name": "Variable8",
        "offset": 82944,
        "size": 442368
      },
      "Variable67": {
        "name": "Variable67",
        "offset": 82944,
        "size": 442368
      },
      "Variable5": {
        "name": "Variable5",
        "offset": 82944,
        "size": 884736
      },
      "Variable89": {
        "name": "Variable89",
        "offset": 304128,
        "size": 1990656
      },
      "Variable15": {
        "name": "Variable15",
        "offset": 82944,
        "size": 221184
      },
      "Variable70": {
        "name": "Variable70",
        "offset": 82944,
        "size": 442368
      },
      "Variable93": {
        "name": "Variable93",
        "offset": 304128,
        "size": 1990656
      },
      "Variable60": {
        "name": "Variable60",
        "offset": 2515968,
        "size": 221184
      },
      "Variable81": {
        "name": "Variable81",
        "offset": 967680,
        "size": 6718464
      },
      "Variable76": {
        "name": "Variable76",
        "offset": 82944,
        "size": 82944
      },
      "Variable64": {
        "name": "Variable64",
        "offset": 304128,
        "size": 221184
      },
      "Variable50": {
        "name": "Variable50",
        "offset": 2294784,
        "size": 221184
      },
      "Variable54": {
        "name": "Variable54",
        "offset": 82944,
        "size": 221184
      },
      "Variable66": {
        "name": "Variable66",
        "offset": 82944,
        "size": 442368
      },
      "Variable87": {
        "name": "Variable87",
        "offset": 304128,
        "size": 1990656
      },
      "Variable40": {
        "name": "Variable40",
        "offset": 2294784,
        "size": 221184
      },
      "Variable14": {
        "name": "Variable14",
        "offset": 82944,
        "size": 221184
      },
      "Variable69": {
        "name": "Variable69",
        "offset": 82944,
        "size": 442368
      },
      "Variable44": {
        "name": "Variable44",
        "offset": 2515968,
        "size": 221184
      },
      "Variable30": {
        "name": "Variable30",
        "offset": 2294784,
        "size": 221184
      },
      "Variable80": {
        "name": "Variable80",
        "offset": 82944,
        "size": 82944
      },
      "Variable34": {
        "name": "Variable34",
        "offset": 82944,
        "size": 221184
      },
      "Variable85": {
        "name": "Variable85",
        "offset": 525312,
        "size": 1769472
      },
      "Variable78": {
        "name": "Variable78",
        "offset": 82944,
        "size": 82944
      },
      "Variable111": {
        "name": "Variable111",
        "offset": 967680,
        "size": 6718464
      },
      "Variable3": {
        "name": "Variable3",
        "offset": 82944,
        "size": 884736
      },
      "Variable13": {
        "name": "Variable13",
        "offset": 82944,
        "size": 221184
      },
      "Variable103": {
        "name": "Variable103",
        "offset": 304128,
        "size": 1990656
      },
      "Variable24": {
        "name": "Variable24",
        "offset": 2515968,
        "size": 221184
      },
      "Variable68": {
        "name": "Variable68",
        "offset": 82944,
        "size": 442368
      },
      "Variable72": {
        "name": "Variable72",
        "offset": 82944,
        "size": 884736
      },
      "Variable107": {
        "name": "Variable107",
        "offset": 525312,
        "size": 1769472
      },
      "Variable75": {
        "name": "Variable75",
        "offset": 82944,
        "size": 884736
      },
      "Variable105": {
        "name": "Variable105",
        "offset": 525312,
        "size": 1990656
      },
      "Variable83": {
        "name": "Variable83",
        "offset": 967680,
        "size": 3538944
      },
      "Variable10": {
        "name": "Variable10",
        "offset": 82944,
        "size": 442368
      },
      "Variable65": {
        "name": "Variable65",
        "offset": 304128,
        "size": 221184
      },
      "Variable97": {
        "name": "Variable97",
        "offset": 304128,
        "size": 1990656
      },
      "Variable0": {
        "name": "Variable0",
        "offset": 0,
        "size": 82944
      },
      "Variable55": {
        "name": "Variable55",
        "offset": 82944,
        "size": 221184
      },
      "Variable99": {
        "name": "Variable99",
        "offset": 82944,
        "size": 1990656
      },
      "Variable71": {
        "name": "Variable71",
        "offset": 82944,
        "size": 884736
      },
      "Variable45": {
        "name": "Variable45",
        "offset": 2515968,
        "size": 221184
      },
      "Variable109": {
        "name": "Variable109",
        "offset": 967680,
        "size": 3538944
      },
      "Variable91": {
        "name": "Variable91",
        "offset": 82944,
        "size": 1990656
      },
      "Variable74": {
        "name": "Variable74",
        "offset": 82944,
        "size": 884736
      },
      "Variable35": {
        "name": "Variable35",
        "offset": 82944,
        "size": 221184
      },
      "Variable4": {
        "name": "Variable4",
        "offset": 82944,
        "size": 884736
      },
      "Variable9": {
        "name": "Variable9",
        "offset": 82944,
        "size": 442368
      },
      "Variable25": {
        "name": "Variable25",
        "offset": 2515968,
        "size": 221184
      },
      "Variable20": {
        "name": "Variable20",
        "offset": 2294784,
        "size": 221184
      },
      "Variable101": {
        "name": "Variable101",
        "offset": 304128,
        "size": 1990656
      }
    }
  },
  "inputs": [
    "Variable0"
  ],
  "outputs": [
    "Variable80"
  ],
  "licenses": {
    "webdnn": "(C) Machine Intelligence Laboratory (The University of Tokyo), MIT License"
  }
}